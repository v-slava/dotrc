# markdown (.md) viewer:
grip -b readme.md

# debug vim plugins:
vim -V9log_file.txt [your_vim_args]

# some yocto commands (tags: bitbake):
devtool status
devtool modify busybox
# now do your changes
devtool build busybox
# now create git commits
devtool finish busybox YOUR_LAYER_NAME
bitbake -c configure busybox
bitbake -c devshell [busybox|virtual/kernel] # run make afterwards
MAKEFLAGS="$EXTRA_OEMAKE"
bitbake virtual/kernel -c clean && bitbake virtual/kernel -c do_configure
bitbake -k # build as much as possible despite errors
bitbake -e <target> # print environment
bitbake -g -u taskexp bitbake_target
bitbake -g -u depexp bitbake_target
bitbake -g -n -v bitbake_target
vim pn-buildlist
xdot task-depends.dot
xdot recipe-depends.dot
bitbake -k -c fetchall  <target|world>
bitbake -c fetchall --dry-run
bitbake core-image-sato -c fetchall

# python print stacktrace (dump stack):
import traceback
traceback.print_stack()

# find out which process modified / created / deleted file:
sudo apt-get install auditd
# Start auditing:
sudo auditctl -w /some/path/to/file
# Afterwards see file: /var/log/audit/audit.log

# linux printer (cups) settings:
# usermod -a -G lpadmin YOUR_USER_NAME
http://localhost:631/admin

# Network traffic monitoring:
sudo apt-get install vnstat
# Update statistics:
sudo vnstat -i wlp3s0 -u
# Print report
vnstat -i wlp3s0 -d
# rx today:
vnstat -i wlp3s0 --oneline | cut -d';' -f4
# tx today:
vnstat -i wlp3s0 --oneline | cut -d';' -f5

# simple http server to transfer files over local network:
woof FILE

# install busybox (see also: other_files/create_rootfs.sh):
busybox --install -s

# Test CAN interface:
# on server:
candump CAN_INTERFACE
# on client
cansend CAN_INTERFACE 543#11.22.33.44.55

# simple web site to access without DNS:
http://www.columbia.edu/~fdc/sample.html
http://128.59.105.24/~fdc/sample.html

# telegram bot:
0) Bot API reference:
      https://core.telegram.org/bots/api
1) Use BotFather
      tg://resolve?domain=BotFather
      to create new bot. Use command
      /newbot
      As asked by BotFather, enter bot's name and username for the bot.
      As a result bot will be created. Remember bot's token.
2) determine your <telegram ID>.
      https://api.telegram.org/bot<token>/getUpdates
3) send message to you:
      https://api.telegram.org/bot<token>/sendMessage?chat_id=<telegram ID>&text=hello_world

colordiff -uN "$@"

# execute COMMAND every 2 seconds, showing output fullscreen and highlight diff:
watch -d -n 2 COMMAND

# transmission disable password:
in /etc/transmission-daemon/settings.json set:
"rpc-authentication-required": false,

# transmission add torrents:
transmission-remote -a $MAGNET_URL

# transmission list all torrents:
transmission-remote -l

# transmission show detailed info (for all torrent):
transmission-remote -t all -i

# cron:
crontab -e
# run script.sh at every hour at minute 42:
42 *   *   *   *      /home/user/script.sh

lsusb analog:
usb-devices

# gcc show detailed default optimization options:
gcc --help=optimizers -Q -O0
# disable all optimizations:
gcc --help=optimizers -Q -O0 2>&1 | perl -ane 'if ($F[1] =~/enabled/) {$F[0] =~ s/^\s*-f/-fno-/g;push @o,$F[0];}} END {print join(" ", @o)'

# To find out what gcc -pthread actually does:
gcc -dumpspecs | grep pthread

# get current tty device (terminal):
tty
readlink -f /proc/self/fd/0

# autologin on virtual terminal:
/sbin/agetty -a USER --noclear tty2 linux

# Escape sequence (color):
echo -e '\e[0;31mRED TEXT\e[mNORMAL TEXT'

# List all known character set encodings:
iconv -l

# Convert to UTF-8:
iconv -f ISO-8859-1 -t UTF-8 < INPUT_FILE > OUTPUT_FILE

# Check whether file is valid UTF-8:
iconv -f UTF-8 FILE > /dev/null
echo $?
# 0 (success) => valid UTF-8

# Detect encoding:
uchardet FILE

# list available MTP devices:
jmtpfs -l
# mount MTP device:
jmtpfs MOUNT_POINT
# umount MTP device:
fusermount -u MOUNT_POINT

# zenity: specify font properties:
zenity --info --text '<span foreground="blue" font="32">Some\nbig text</span>\n\n<i>(it is also blue)</i>'

# disable address space randomization:
echo 0 > /proc/sys/kernel/randomize_va_space

# Find everything. Exclude directory 'dir1':
find -path ./dir1 -prune -o -print

# Find files only. Exclude directory 'dir1':
find -path ./dir1 -prune -o -type f -print

# Find file '*ctags*' in system folders:
find / -path /dev -prune -o -path /home -prune -o -path /lost+found -prune -o -path /media -prune -o -path /mnt -prune -o -path /proc -prune -o -path /root -prune -o -path /run -prune -o -path /sys -prune -o -path /tmp -prune -o -path /var -prune -o -type f -name '*ctags*' -print

# Find *.c files only in specified path:
find -path './some/path*' -name '*.c

# Execute command for each element found:
find -exec CMD args_before {} args_after \;

# grep stop after first match:
grep -m 1 OTHER_OPTIONS

# Find \r symbols:
grep -r $'\r'

# Print symbols from ELF fils and sort them by their size:
nm --print-size --size-sort file.elf

# Find symbol in directory with libraries / object files:
find DIR -type f -name '*.a' | xargs nm -o | grep ' SYMBOL'

# Display symbols, exported by a shared library (even stripped one):
nm -D /path/to/libSOMETHING.so

nm --defined-only ELF_FILE | sed -e '/ \$[dt]$/d' | cut -d' ' -f3 | c++filt | sort

# Compare symbols in 2 elf files:
nm YOUR_FILE.elf | grep -v ' $a$' | grep -v ' $d$' | grep -v ' $t$' | grep -v '         U ' | cut -d' ' -f3  | c++filt | sort > compare_this.txt

# Uboot commands (press any key at early boot stage to enter uboot console):
help
help CMD
printenv
printenv VARIABLE
echo $VARIABLE
printenv -a
setenv VARIABLE "VALUE"
# unset variable:
setenv VARIABLE
saveenv
reset
if test $VARIABLE = "VALUE" ; then echo "equals" ; else echo "not equals" ; fi
bootm ADDRESS [ADDITIONAL_ARGS]
boot

# If libreoffice draw is slow (with grid enabled), turn on the following settings:
Tools -> Options -> View -> Use OpenGL for all rendering (on restart)
Tools -> Options -> View -> Force OpenGL even if blacklisted (on restart)
# Save document often, beware of OpenGL driver crashes!

# Google test (gtest) test filter:
./test_executable --gtest_filter='PREFIX_1*:PREFIX_2*:PREFIX_3*'

# Send file over tcp (netcat, nc) server -> client:
# on server:
cat FILE | nc -l -p 9999
# on client:
nc SERVER_IP 9999 < /dev/null > FILE
# Send file over tcp (netcat, nc) client -> server:
# on server:
nc -l -p 9999 > FILE < /dev/null
# on client:
cat FILE | nc SERVER_IP 9999

# View open ports on local host (a), PIDs (p), do not resolve hosts (n).
netstat -apn # Try also as root.
# View open ports on remote server (1-100 = port range):
nc -z -v 192.168.0.1 1-100
# View IP addresses (devices up and running) in local network (IP range):
nmap -sn 192.168.1.0/24

# Install GPG key for third-party apt repository:
wget http://apt.llvm.org/llvm-snapshot.gpg.key
apt-key add llvm-snapshot.gpg.key

# udev commands:
udevadm info -q path --path /sys/devices/soc/...
# reload udev rules:
udevadm control -R
# debug udev rules (note: prefix "/sys" is missing):
udevadm test /devices/pci0000:00/0000:00:14.0/usb1/1-3
# debug /dev/ nodes creation (mknode, udev):
udevadm monitor --property
# test udev rule:
udevadm control --reload-rules
udevadm trigger
# udev run shell script (bash) for USB device (should have "#!/bin/bash"):
ATTR{idVendor}=="2444", ATTR{idProduct}=="0202", RUN+="/full/path/to/my/shell/script"
# udev symlink (/dev/my_symlink) for USB device:
ATTR{idVendor}=="2444", ATTR{idProduct}=="0202", SYMLINK+="my_symlink"
# Permissions are applied to USB devices in:
/dev/bus/usb/{001, 002, ...}

# USB device sysfs entry example (udevadm monitor):
 USB host controller (hierarchy) start             USB bus            USB device configuration
             |                                       | |                         |
             v                                       v v                         v
/sys/devices/pci0000:00/0000:00:1e.0/0000:05:04.1/usb3/3-2/3-2.3/3-2.3.4/3-2.3.4:1.0/...
                        ^            ^                   ^   ^ ^   ^ ^ ^   ^ ^ ^   ^
                        |            |                   |   | |   | | |   | | |   |
                        |    USB host controller         |   | |   | | |   | | | USB interface
                        |                                |   | |   | | |   | | |
                   PCI bridge                      USB ports / devices (hubs hierarchy)

# Audio CD is can't be mounted.
# Listen track #1 from audio CD:
mplayer -cdrom-device /dev/cdrom -cache 5000 cdda://1
# Determine number of audio tracks:
udevadm info /dev/cdrom | grep ID_CDROM_MEDIA_TRACK_COUNT
# Extract all audio tracks in mp3 format from audio cd:
apt-get install abcde eyed3
abcde -o mp3

# Print file capabilities:
getcap FILE
# Add capabilities to a file:
setcap 'cap_sys_rawio+ep' FILE

# Print properties of window (find PID by clicking):
xprop

# gcc print architecture
gcc -dumpmachine
gcc -v | grep arch
gcc -Q --help=target | grep arch

# Preprocess source file for further compilation:
gcc FILE.c -o FILE.i -E -P -dN
# (see -dCHARS in "man gcc")

# gcc save preprocessed and assembler files:
gcc -save-temps=obj

# Standard compiler include search paths:
touch foo.h && gcc -c -v foo.h

# Standard compiler macros (preprocessor, defines):
gcc -dM -E - < /dev/null

# Preprocess using cmake:
1) go to your build directory;
2) execute commands like: "make some_file.cpp.i".

# Preprocess using msvc:
1) Create new win32 console msvc project. Add single source file with the following contents:
   #include "preprocessed.i"
   int main(void) { return 0; }
2) Copy to clipboard YOUR_COMPILATION_OPTIONS:
   in Visual Studio: right click on your project -> Properties -> Configuration Properties -> C/C++ -> Command Line.
3) Create file "preprocess.bat" with the following contents:
     call "C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat" x64 || goto error
     cd C:\your\path\to\visual\studio\project || goto error
     cl.exe YOUR_COMPILATION_OPTIONS ^
     some_file.cpp /C /EP > C:\your\path\to\preprocessed\preprocessed\preprocessed.i || goto error
     exit
     :error
     set /p DUMMY=Hit ENTER to exit...
4) Run "preprocess.bat"
5) Compile your preprocessing project.

# start bash with empty environment (no environment variables):
env -i bash --noprofile --norc

# bash "set -e" documentation: search for "Exit immediately if" in "man bash"

# bash save and restore options (set -e, ...):
state=$(set +o;shopt)
# do what you want with options here
eval "$state" # restore options

# preprocess bash script:
#!/bin/bash -x
# in "help set":
# -x  Print commands and their arguments as they are executed.
bash -x ./some_script.sh 2>&1 1>/dev/null | grep '^+ ' | cut -c 3-

# Bash use aliases in shell script:
shopt -s expand_aliases
source ~/.bashrc

# To inspect bash keyboard mapping:
bind -P

# Start logging bash session:
script IN_OUT_LOG_FILE -t 2>TIMING_LOG_FILE

# Read logging bash session:
scriptreplay -t TIMINT_LOG_FILE IN_OUT_LOG_FILE
cat <file_name>
less -r|-R IN_OUT_LOG_FILE

# bash assume that $SOME_VAR contains hex value (without 0x), convert it to decimal:
echo $((16#$SOME_VAR))

# Start (default clear) bash  with empty environment and do not source anything:
env -i bash --noprofile --norc

# Where to define environment variables:
/etc/environment
/etc/bash.bashrc
/etc/profile
/etc/profile.d/*
/etc/pam.d/*
~/.pam_environment
~/.profile
~/.bash_profile
~/.bash_login
~/.bashrc

# Unset environment variable (bash):
unset ENV_VAR_NAME

# use russian windows locale:
LANG=ru_RU.CP1251 PROGRAM_TO_RUN

# Switch to russian language (add to ~/.bashrc):
export LANG=ru_RU.UTF-8
export LANGUAGE=ru
# See also /etc/default/locale

# Signal bash to include filenames beginning with a `.'
# in the results of pathname expansion:
shopt -s dotglob

# Icecream:
sudo apt-get install icecc icecc-monitor
# kill icecc-scheduler, if present
sudo service iceccd restart
# create symlinks "clang" and "clang++" in "/usr/lib/icecc/bin"
cd $HOME/other/toolchains/icecc
/usr/lib/icecc/icecc-create-env --gcc /usr/bin/gcc /usr/bin/g++
/usr/lib/icecc/icecc-create-env --clang /usr/bin/clang /usr/bin/clang++
# Icecream GUI monitor:
icemon
# for environment settings see .bashrc

# List all pkg-config (tags: pkgconfig) packages:
pkg-config --list-all
# Get compile flags:
pkg-config PKG_NAME --cflags-only-I

# Upgrade when "The following packages have been kept back:":
apt-get dist-upgrade

# Upgrade all packages:
apt-get --with-new-pkgs upgrade

# Show packages (tags: update / upgrade) history:
less /var/log/apt/history.log

# Reinstall package (create missing configs):
apt-get install --reinstall -o Dpkg::Options::="--force-confask,confnew,confmiss" PACKAGE

# Show which packages can be upgraded from backports:
apt-get -s -t jessie-backports dist-upgrade

# install package from backports:
apt-get -t jessie-backports install PACKAGE

# install package of specified version:
apt-get install PACKAGE=VERSION

# install package of specified architecture (i386):
apt-get install PACKAGE:ARCHITECTURE

# Debian packaging from source:
# Debian download source package:
apt-get source PACKAGE
Got sources with patches applied.

# Install build dependencies:
apt-get build-dep PACKAGE

# Clear out the local repository of retrieved package files:
apt-get clean

# Show dependencies to be installed for a package:
apt-get install -s <package_name>
apt-rdepends --state-show NotInstalled --state-follow NotInstalled <package_name>
# Show reverse dependencies:
apt-cache rdepends <package_name>

# Download sources for a package:
apt-get source --download-only <package_name>

# Download package from repository:
apt-get download <package_name>

# list installed packages by installation date:
ls -lt /var/lib/dpkg/info/*.list | cut -d' ' -f 5-

# Install dpkg (debian) package (packet):
dpkg -i some_package.deb

# Remove dpkg (debian) package (packet):
dpkg -r some_package.deb

# dpkg restore broken installation:
dpkg --configure -a

# dpkg apt-get add architecture x86-64 x86_64:
sudo dpkg --add-architecture <arch>
dpkg --print-foreign-architectures
sudo apt-get update
dpkg --remove-architecture <arch>

# Build package from source and do not sign anything:
dpkg-buildpackage -us -uc
# View build flags:
dpkg-buildflags
# Use -O0 instead of -O2:
export DEB_BUILD_OPTIONS=noopt
# Force CFLAGS value:
export DEB_CFLAGS_SET='-g3 -O0'

# Install package without root privileges:
mkdir -p ~/root_dir/var/lib
cp -r /var/lib/dpkg ~/root_dir/var/lib/
dpkg --force-not-root --root=$HOME/root_dir --log=$HOME/var_log_dpkg.log -i <package_name>

# Show files in package:
apt-file list <package_name_from_repository>
dpkg -L <installed_package_name>
dpkg -c <package>.deb

# Extract files from package:
ar xv <package>.deb

# Search for a file from installed packages:
dpkg -S FILE

# Find all packages that provide www-browser:
aptitude search '~Pwww-browser'

# show window properties:
xprop
xwininfo

# show all windows, PIDs and process names:
wmctrl -p -G -l

# show all windows:
xlsclients -a -l

# hide window:
xdotool windowunmap $WIN

# show window:
xdotool windowmap $WIN

# move specified window:
xdotool windowmove $WIN $X $Y

# resize specified window:
xdotool windowsize $WIN $WIDTH $HEIGHT

# move and resize specified window:
wmctrl -i -r $WIN -e 1,$X,$Y,$WIDTH,$HEIGHT

# Setup desktop wallpaper (i3wm):
feh --bg-center $DOTRC/other_files/desktop_wallpaper.png

# Convert elf to binary:
objcopy -O binary IN_FILE.elf OUT_FILE.bin
# List targets, acceptable by objcopy:
objdump -i
# Dump single section into binary from object file:
arm-none-eabi-objcopy -O binary --only-section=.MySection -I elf32-littlearm IN_FILE.o OUT_FILE.bin
arm-none-eabi-objcopy -O binary --only-section=.text ELF_FILE BIN_FILE

# Some random objdump flags:
objdump --prefix-address --show-raw-insn -D -S -z -b binary -m arm -Mforce-thumb

# Pulseaudio verbose output:
pulseaudio -k && pulseaudio -vvvv
# Do not respawn pulseaudio: in file /etc/pulse/client.conf
autospawn = yes
# Get list of sound cards:
pacmd list-cards
# Get current card's active profile (bluetooth):
pacmd list-cards | grep 'active profile'
# Change current card's active profile (bluetooth):
pactl set-card-profile CARD_INDEX PROFILE_NAME
# Get list of output devices (speaker, ...):
pactl list sinks
# Get list of input devices (microphone):
pactl list sources
# Get list of application producing sound:
pacmd list-sink-inputs

# i3wm turn off monitor (move workspaces to LVDS-1):
xrandr --output HDMI1 --off

# Disable stdout buffering:
stdbuf -o0 YOUR_CMD
LD_PRELOAD=/usr/lib/coreutils/libstdbuf.so _STDBUF_O=0 YOUR_CMD

# Search additional path for libraries at runtime:
LD_LIBRARY_PATH=/some/path/to/libs YOUR_CMD

# Set setuid bit in order to dump packages as non-root user
# (this doesn't work for usb dumping with dumpcap):
chmod u+s /usr/sbin/tcpdump
# Enable USB monitoring:
su -c 'modprobe usbmon'
# Dump packets and feed them to wireshark through unnamed pipe:
tcpdump -i usbmon1 -w - -U | wireshark -k -i -

# Use wireshark plugin (dissector):
wireshark -X lua_script:/path/to/plugin/file.lua

# wireshark IP filter:
(ip.src == SOME_IP) || (ip.dst == SOME_IP)

# port IP filter:
(tcp.port == 443) || (udp.port == 23)

# List interfaces available:
dumpcap -D
# Dump packets to file:
dumpcap -i eth0 -w FILE
# Display captured packets from file:
wireshark -r FILE
# Dump packets to stdout:
dumpcap -i eth0 -w -
# Dump packets and feed them to wireshark through unnamed pipe
# (doesn't work for usb unless you are root, setuid doesn't help):
dumpcap -i eth0 -w - -P | wireshark -k -i -

# read the whole content of the chip flash:
edbg -t atmel_cm7 -r -f full_flash.bin
# erase flash memory:
edbg -t atmel_cm7 -e
# write binary to flash memory:
edbg -t atmel_cm7 -bpv -f some_flash.bin

# gtypist in russian:
gtypist ru.typ

# ripgrep (rg):
rg -g '*.dts' -g '*.dtsi' -g '!*.c' REGEX

# search only in files, that match regex (silverlight searcher):
ag SEARCH_REGEX -G FILE_PATH_REGEX
# Search only in *.h and *.cpp files:
ag SEARCH_REGEX -G '(\.h$|\.cpp)'
# Search only in *.cpp files, which path contains "tools":
ag SEARCH_REGEX -G '(?=.*tools)(?=.*\.cpp$)'

# smplayer hotkeys:
j - loop subtitle (e.g. none, rus, eng, ...)
v - switch subtitle visibility
a - change aspect ratio

# Compose key sequences (not works for some apps):
# 1) add the following contents:
# <Multi_key> <a> : "ä"
# <Multi_key> <b> <r> : "Best regards," # email ending
# to file '/usr/share/X11/locale/en_US.UTF-8/Compose'
# 2) set Alt_R as compose key:
xmodmap -e 'keycode 108 = Multi_key'
# 3) press sequentially <Caps_lock>, <a> to produce <ä>

# Use Mode_switch to type characters from alternative keyboard:
xmodmap -e 'keycode 108 = Mode_switch'
# Press Alt_R+s to produce 'ы'
# See xmodmap -pke for symbols assigned

# Linker: issue linker map (see what consumes memory):
-Wl,--print-map
-Wl,-Map=file.map

# Linker: print linker script:
ld --verbose

# Verbose linking (linker: print linker script, linked objects, libraries, etc.):
gcc 1.o 2.o -o out.elf -Wl,--verbose

# statically link libstdc++ library, but dynamically everything else (no C++ stdlib):
gcc main.c -static-libstdc++

# Create static executable with rust:
# 1. Emit object file:
rustc -O --emit obj main.rs
# 2. Print linker arguments:
rustc -O -Z print-link-args main.rs
# Use printed link command with the following modifications:
# 1) add "-static", "-static-libgcc"
# 2) change "gcc_s" => "gcc_eh"
# 3) delete "-pie", "-Wl,-Bdynamic"

# show lines in file (head, tail):
tail -n +${START_LINE} | head -n $NUM_LINES

# get line with specified number from file:
sed -n '<line number>p' < file

# Delete (remove) lines matching regex from file:
sed -i OLD_FILE -e '/REGEX/d'

# Delete specified lines interval from file:
sed -i OLD_FILE -e '<start line>,<end line>d'

# Insert specified line into text file under a given line number:
sed -i OLD_FILE -e '<line number>i<text to be inserted>'
# A line, which is currently under <line number> will be
# under <line number>+1 after execution.

# Replace string by regex:
cat file_before | sed -e 's/REGEX/STRING_AFTER/g' > file_after

# Delete strings by regex:`
cat file_before | sed -e '/REGEX/d' > file_after

# Disable GNU Make builtin rules:
MAKEFLAGS += --no-builtin-rules --no-builtin-variables --no-print-directory
export MAKEFLAGS
# .SUFFIXES:

# get Makefile directory in Makefile:
MAKEFILE_DIR := $(dir $(realpath $(lastword $(MAKEFILE_LIST))))

# Debug Makefile:
# Write "SHELL := sh -x" to Makefile you'd like to debug
make -d
make -p
remake SOME_OPTIONS
# Try also replacing /usr/bin/make with wrapper shell script that calls "remake -x"
# Variables "V" or "VERBOSE" are normally analysed by Makefiles:
make V=1
make VERBOSE=1
# Create linux man pages (docs):
make mandocs
make installmandocs # installs in /usr/local/man/man9
# Get info about all targets (linux kernel only):
make help
# Execute linux kernel self tests:
make kselftest
# See also ktest.pl (build kernel, boot it on remote machine and run some
# userspace program).
# See also: LTP
# See also: https://kernelci.org/

# linux kernel boot sequence (tags: startup, debugging, jtag, system):
uboot:
    boot_jump_linux()
linux/arch/arm/boot/compressed/vmlinux (decompression stub),
address offset is in uboot's "bootX" command arguments
    start
    __enter_kernel
linux/vmlinux, address offset -0xC0000000:
    stext
    __turn_mmu_on
        3 instructions
linux/vmlinux, address offset 0:
    __mmap_switched
    start_kernel
    smp_init

# linux kernel disable optimizations (CFLAGS):
CFLAGS_file_name.o := -O0
# see also $DOTRC/other_files/no_optimize_gcc_wrapper.sh

# linux kernel loading:
insmod executes syscall init_module -> sys_init_module() in kernel
rmmod executes syscall delete_module -> sys_delete_module() in kernel

# linux kernel errno defines (error codes, definitions [1; 34]):
include/uapi/asm-generic/errno-base.h
# linux kernel errno defines (error codes, definitions [35; 133]):
include/uapi/asm-generic/errno.h
# linux kernel errno defines (error codes, definitions [512; 529]):
include/linux/errno.h

# blacklist (exclude) linux kernel module (I didn't check it):
echo "blacklist MODULE_NAME" >> /etc/modprobe.d/blacklist.conf
# See also files in /etc/modules.d/ (use '#' to comment-out module name)

# include linux kernel module:
echo "MODULE_NAME" >> /etc/modules

# Module dependencies:
lsmod
cat /proc/modules
modprobe --show-depends MODULE
/lib/modules/KERNEL_VERSION/modules.dep
/lib/modules/KERNEL_VERSION/modules.dep.bin
/lib/modules/KERNEL_VERSION/modules.symbols
/lib/modules/KERNEL_VERSION/modules.symbols.bin
# See man 8 depmod

# Install linux kernel modules:
make modules
make modules_install INSTALL_MOD_PATH=YOUR_ROOTFS_ROOT

# Install linux kernel headers:
make headers_install INSTALL_HDR_PATH=YOUR_ROOTFS_ROOT

# linux kernel modules dependencies commit:
# driver core: Functional dependencies tracking support
9ed9895370aedd6032af2a9181c62c394d08223b

# gcc output rules for make describing dependencies:
gcc FILE.c -o FILE.d -MM -MT FILE.o
# In Makefile:
-include FILE.d

# Exclude an option from variable in Makefile:
OPTS += SomeOption
OPTS := $(filter-out SomeOption,$(OPTS))

# Generate project for eclipse:
cmake -G "Eclipse CDT4 - Unix Makefiles" -DCMAKE_BUILD_TYPE=Debug ../cmake_demo

# Use ninja build system generator:
cmake -G Ninja

# Specify install directory for cmake:
cmake -DCMAKE_INSTALL_PREFIX=.. ../src_dir

# create JSON file with build commands, used by clang tooling interface (rtags):
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1
bear make
compiledb make
./scripts/gen_compile_commands.py # for linux kernel >= v5.0
# need additional processing:
ninja -v
ninja -t commands
ninja -t compdb ninja_rule_1 ninja_rule_2 ...
make VERBOSE=1

# Start rtags daemon (custom toolchain):
rdm -R

# C++ hex output format example:
std::cout << std::hex << std::setfill('0') << std::nouppercase << std::setw(8);

# print sizeof(SomeType) at compile time:
template<int s> struct UnusedStruct;
UnusedStruct<sizeof(SomeType)> UnusedStructInstance;

# list available fonts:
fc-list

# update fonts cache:
fc-cache -fv

# pdf viewer with edit support:
evince
# pdf viewer with editable XFA forms:
masterpdfeditor5
# Extract attachment from encrypted pdf:
pdftk <input_file.pdf> input_pw <password> unpack_files

# Extract images from pdf file:
mkdir /tmp/images_folder && pdfimages -all input.pdf /tmp/images_folder

# cut pages range from pdf:
pdftk A=in_1.pdf input_pw='PASSWORD' B=in_2.pdf cat A3-5 B3left A2right output out.pdf
# rotate pages in pdf:
pdftk in.pdf cat 1-endright output out.pdf
# Create pdf file from images (jpg/png), need to install imagemagick:
# apt-get install imagemagick
convert page*.png mydoc.pdf
# extract images from pdf:
pdfimages input.pdf output_folder

# compress (minimize) image size (jpg, png):
mogrify -quality "80%" -resize 1048x768 file.jpg

# rotate image clockwise:
convert in.jpg -rotate 90 out.jpg

# Set the pipeline's return status to the value of the  last  (right‐most)
# command to exit with a non-zero status, or zero if all commands exit
# successfully:
set -o pipefail

# icedove / thunderbird:
# see ~/other/icedove_thunderbird
# use firetray addon
http://forums.mozillazine.org/viewtopic.php?f=48&t=72994
http://mozilla.dorando.at/keyconfig.xpi
# See file .icedove/PROFILE/mimeTypes.rdf for default browser

# Determine unit tests coverage:
gcc UNIT_TESTS.c -o UNIT_TESTS.out --coverage
gcov UNIT_TESTS.out

# Reformat source file with uncrustify:
uncrustify -f FILE_BEFORE.c -o FILE_AFTER.c

# Format source file with astyle:
astyle --style=ansi FILE1 [FILE2] [...]
# Documentation: /usr/share/doc/astyle/html/astyle.html

ARM stack in debug:
# f[i] = frame #i.
# fp[i] = frame pointer #i (R7 for Thumb2, R11 for ARM 32 bit, see gcc flag -fno-omit-frame-pointer).
# sp[0] = $sp; f[0] = *$fp; pc[0] = $pc; pc[1] = $lr; pc[i] = lr[i - 1] - 1.
                     |-----------|
                     |           | addr
                     |-----------|
f[i] = sp[i + 1] --> |           | addr - 4
                     |-----------|
                     |   lr[i]   | return address (not present for leaf function)
                     |-----------|
                     |   fp[i]   | = f[i]
                     |-----------|
                     |           |
                     | locals[i] | optional
f[i - 1] = sp[i] --> |           |
                     |-----------|
                     | lr[i - 1] | return address (not present for leaf function)
                     |-----------|
                     | fp[i - 1] | = f[i - 1]
                     |-----------|
                     |    ...    |
                     |-----------|

# AddressSanitizer detects:
# - stack, global and heap buffer overflow;
# - use after free();
# - use after return (stack); # ASAN_OPTIONS=detect_stack_use_after_return=1
# - use after scope (stack);  # -fsanitize-address-use-after-scope (currently I can't compile this, on clang-3.8, should be enabled by default)
# - memory leak;
# - double free;
# - invalid free;
gcc FILE.c -fsanitize=address -g -O0 -fno-common -fno-omit-frame-pointer -fno-optimize-sibling-calls -o FILE.out
PATH=/usr/lib/llvm-3.8/bin:$PATH ASAN_OPTIONS=detect_stack_use_after_return=1 ./FILE.out
# Note: PATH is required for symbolizer to work. See also ASAN_SYMBOLIZER_PATH=/usr/bin/llvm-symbolizer-3.8
# Note: -fsanitize=leak is included in -fsanitize=address
# View runtime options:
ASAN_OPTIONS=help=1 ./FILE.out
# Set some runtime options:
ASAN_OPTIONS=verbosity=1:malloc_context_size=20 ./a.out
# For Cmake see also target: make check-asan

# MemorySanitizier detects use of uninitialized variables:
gcc FILE.c -fsanitize=memory -fsanitize-memory-track-origins -g -O0 -pie -fPIE -fno-omit-frame-pointer -fno-optimize-sibling-calls

# ThreadSanitizer detects data races:
gcc FILE.c -fsanitize=thread -g -O0 -pie
# Note: -pie required only at linkage.

# Undefined behaviour sanitizer:
gcc FILE.c -fsanitize=undefined -fno-omit-frame-pointer 
PATH=/usr/lib/llvm-3.8/bin:$PATH UBSAN_OPTIONS=print_stacktrace=1 ./FILE.out

# Use valgrind for dynamic memory analysis:
valgrind --error-exitcode=1 --leak-check=full --track-origins=yes EXECUTABLE.out
# --read-var-info=yes
valgrind --vgdb=yes --vgdb-error=ERROR_NUMBER EXECUTABLE.out
vgdb --pid=YOUR_PID --port=9999 # now you can connect to this port from remote PC

# Use clang static analysis:
scan-build BUILD_COMMAND
# List some clang command line options:
clang++ -cc1 --help
# List scan-build default checkers:
scan-build --help-checkers
# List all available analyzers:
clang++ -cc1 -analyzer-checker-help
# Use one specific analyzer:
clang++ -cc1 -analyze -analyzer-checker=core.DivideZero FILE.cpp
# Verbose scan-build execution:
scan-build -v -v -v BUILD_COMMAND

# clang-tidy (linter):
# List all checks:
clang-tidy-3.8 -checks=* -list-checks
# Analize program:
clang-tidy-3.8 -checks=* main.cpp

# See also $DOTRC/other_files/check_program.sh

# xargs specify parameters order (you can use anything as replace_str):
echo "stdin args" | xargs -I replace_str CMD args_before replace_str args_after

# xargs spaces (files with spaces, print size in bytes):
find -type f -print0 | xargs -0 du -b

# Create initramfs:
mkinitramfs -o initramfs.igz

# Pack initramfs:
cd EXTRACTED_INITRD && find | cpio -o -H newc | gzip -9 > /path/to/initramfs.igz

# Extract initramfs:
cd FOLDER_TO_EXTRACT_INTO && gunzip -c -9 /boot/initrd.img-3.11.0-12-generic | cpio -i -d -H newc --no-absolute-filenames
unmkinitramfs "$FILE_FULL_PATH" FOLDER_TO_EXTRACT_INTO

# View progress using coreutils viewer (cv, progress viewer):
progress -wm

# Compress folder by tar:
tar cf tar_name.tar ./source_directory/*
tar czf archive.tar.gz /path/to/directory

#pragma pack(push, 1)
#pragma pack(pop)

# assert.h : assert() -DNDEBUG to turn off

# View bluetoothctl commands:
echo help | bluetoothctl

# pactl -- set-sink-volume 2 +3%

# sound application (output):
pacmd list-sink-inputs

# if no sound:
$ LANGUAGE=en pacmd list-sinks | grep -i mute
       muted: yes
$ pacmd list-sinks | grep -i index
  * index: 0
$ pacmd set-sink-mute INDEX 0

# sound outputs:
pacmd list-sinks
# index 0 (ports: analog-output-speaker, analog-output-headphones)
# index 1 (bluetooth headset)

# Change port for sink 0:
pactl set-sink-port 0 analog-output-headphones
pactl set-sink-port 0 analog-output-speaker

# volume control (per-sink):
pactl -- set-sink-volume INDEX +3%

# get volume:
LANGUAGE=en pactl list sinks | grep 'Volume: front' | cut -d' ' -f6

# Set time 3 hours back:
date -s "$(date -R -d '-3 hour')"
hwclock -w

# Set timezone (EET = Eastern European Time = UTC+2):
ln -s /usr/share/zoneinfo/Europe/Kiev /etc/localtime

# View timezone:
date +%Z

# View systemd log (from root):
journalctl

# Recursively show control group contents:
systemd-cgls

# Some man pages:
man systemd.target
man systemd.service

# Check whether there is a valid local session within X:
loginctl show-session $XDG_SESSION_ID | grep '\(Remote=\|Active=\)'
# This should show:
Remote=no
Active=yes

# linux cat /proc/cmdline and replace zeros (0) with spaces:
cat /proc/cmdline | xargs -0 echo

# Systemd commands:
systemctl --failed
systemctl list-unit-files
systemctl [--user] list-unit-files # always shows up-to-date information
systemctl is-enabled SERVICE
systemctl status SERVICE
systemctl enable SERVICE
systemctl start SERVICE
systemctl set-default multi-user.target
systemctl get-default
# Kernel command line argument "single" (recovery mode)
# is equivalent to "systemd.unit=rescue.target".
# Default target: graphical.target.
# target example: /lib/systemd/system/graphical.target

# start teamviewer service:
systemctl start teamviewerd.service

# determine wifi network / access point properties (if already connected):
iwlist wlan0 scan

# Connect manually to wifi (wpasupplicant):
wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant/my_wpa_supplicant.conf

# LG G2 path to camera photos:
/storage/emulated/legacy/DCIM/Camera/

# Download video from youtube:
cclive -f best URL
youtube-dl --write-sub URL
# List supported video formats:
youtube-dl -F URL
# Extract mp3:
youtube-dl -f best -x --audio-format mp3 --audio-quality=0 URL
youtube-dl -f best -x --audio-format mp3 --audio-quality=320K URL
curl -L https://yt-dl.org/downloads/latest/youtube-dl -o ~/bin/youtube-dl

# Bluetooth headset alsa:
# /etc/bluetooth/audio.conf:
[General]
Enable=Socket

# cat << EOF >> ~/.asoundrc
pcm.btheadset {
	type plug
	slave {
		pcm {
			type bluetooth
			device "34:DF:2A:07:71:E8"
			profile "auto"
		}
	}

	hint {
		show on
		description "BT Headset"
	}
}

ctl.btheadset {
	type bluetooth
}
# EOF

# Scan for bluetooth devices:
hcitool scan

# On first connect to enter PIN:
bluez-simple-agent hci0 MAC

# Connect to bluetooth headset:
bt-audio -c MAC

# Display active baseband connections:
hcitool con

# Play mp3:
mplayer -ao alsa:device=btheadset file.mp3

# USB flash turn write protection off:
hdparm -R0 /dev/sdX
hdparm -r0 /dev/sdX

# Vim delete empty lines:
:%g/^\s*$/d

# Vim delete lines by regex:
:%g/<regex>/d

# start vim in easy mode and without menu above:
gvim -c ":set go-=T" -c ":set go-=m" -y

# some vim execution example:
vim -p $FILES_LIST -c "let g:Gdiff_arg='$GDIFF_ARG'|exec ':Gdiff ' . g:Gdiff_arg"

# neovim (nvim) for pair programming:
# #1:
NVIM_LISTEN_ADDRESS=127.0.0.1:6666 nvim --headless
nvim-qt --server 127.0.0.1:7777
# #2:
NVIM_LISTEN_ADDRESS=/tmp/nvimsocket nvim -u ~/.vimrc --embed
nvim-qt --server /tmp/nvimsocket

# Read korean text (locale):
apt-get install fonts-baekmuk
LANG=ko_KR.EUC-KR gvim file.cpp

# ssh connect to host on specified port (default port = 22):
ssh -p port user@host

# non-interactive authentication with password:
sshpass -p PASSWORD ssh user@host
sshpass -p PASSWORD scp FILE user@host:/some/path/

# View machines, connected via ssh:
who -a

# Mount folder over SSH:
sshfs -o allow_root,nonempty user_name@server_name_or_IP:/folder/to/mount /mount/point

# Copy files over ssh:
ssh USER_NAME@$IP "tar cz --exclude=*.o -C /path/to dir" | pv > 1.tar.gz
ssh USER_NAME@$IP "cat FILE" | pv -s 1G > FILE

# git extract subfolder to a dedicated repository:
$DOTRC/other_files/git_trim_repo_to_subdir.sh

# git remove (delete) submodule:
1. Delete the relevant section from the .gitmodules file.
2. git add .gitmodules
3. Delete the relevant section from .git/config.
4. git rm --cached path_to_submodule (no trailing slash).
5. Remove the submodule's .git directory:
   rm -rf .git/modules/path_to_submodule
6. Commit the changes:
   git commit -m "Removed submodule <name>"
7. Delete the now untracked submodule files:
   rm -rf path_to_submodule

# View submodule hashes:
git ls-tree HEAD

# git remote -v submodules:
git submodule foreach 'git remote -v'

# svn show remote repository URL (git remote -v):
svn info .

# ~/.ssh/config example:
Host github-custom
  HostName github.com
  User v-slava
  IdentityFile ~/.ssh/id_rsa_something

# Generate SSH keys:
ssh-keygen -t rsa -C "user@email.com"
# Add authorization without password:
ssh-copy-id user@hostname
cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys

# check signature:
gpg --verify FILE.sig FILE
# If got "Can't check signature: public key not found", use:
gpg --recv-keys KEY_ID

# gpg view supported ciphers:
gpg --version
# gpg encrypt file:
gpg --symmetric --cipher-algo AES256 FILE
# gpg decrypt file:
gpg --decrypt FILE > OUT_FILE

# Generate call graph (control flow):
cd src && cflow *.c
# See also: ncc, codeviz, graphviz, rtags, cquery, doxygen (below)

# Use doxygen to generate documentation:
cd OUTPUT_FOLDER
# generate sample Doxyfile:
doxygen -g
# fix Doxyfile (see the following options):
# PROJECT_NAME INPUT RECURSIVE SOURCE_BROWSER INLINE_SOURCES
# STRIP_CODE_COMMENTS GENERATE_LATEX GENERATE_DOCBOOK HAVE_DOT CALL_GRAPH
# CALLER_GRAPH CLASS_GRAPH EXTRACT_ALL EXTRACT_STATIC REFERENCED_BY_RELATION
# REFERENCED_RELATION MACRO_EXPANSION SKIP_FUNCTION_MACROS
edit Doxyfile
# generate documentation:
doxygen
# view generated documentation:
firefox html/index.html

# OpenGL: use software rendering:
LIBGL_ALWAYS_SOFTWARE=1 glxinfo

# Display the whole server certificate chain:
openssl s_client -showcerts -connect developer.mozilla.org:443 </dev/null

# view certificate revocation list:
openssl crl -text -inform {DER|PEM} FILE.crl

# view certificate details:
openssl x509 -text -in CERTIFICATE_FILE

# Add certificate:
cp certificate.crt /usr/share/ca-certificates/
sudo dpkg-reconfigure ca-certificates
# see also folder /etc/ssl/certs

# Scan network for NetBIOS name information (with IP):
nbtscan 192.168.2.3/16
nmap -p 139 -sT '192.168.*.*'

# List samba services available on server:
smbclient -U USER_NAME[%PASSWORD] -L SERVER [-W DOMAIN] [-m {SMB3|SMB2|NT1}]
smbtree -b -N
# mount smb share with cifs-utils with separate credentials file:
mount -t cifs -o [vers={1.0|2.0|2.1|3.0},]credentials=/file/with/smb_credentials //server_name/share_name /mount/point
# Create file with smb credentials:
cat << EOF > /file/with/smb_credentials
username=SomeUserName
password=SomePassword
EOF
# mount smb share with cifs-utils without separate credentials file:
mount -t cifs -o [vers={1.0|2.0|2.1|3.0},]username=SomeUserName,password=SomePassword,domain=SomeDomain //server_name/share_name /mount/point
# See also mount shared folder via smb (package=smbnetfs|fusesmb, no root required)
# mount using gvfs:
gvfs-mount smb://server_name/share_name
# see directory /var/run/user/1001/gvfs/smb-share:server=server_name,share=share_name

# Restart nfs server (ubuntu):
sudo service nfs-kernel-server restart
# edit /etc/exports:
# /mnt_folder 192.168.1.1(rw,sync,no_root_squash,no_subtree_check)
# /mnt_folder *(rw,sync,no_root_squash,no_subtree_check)

# Download file over TFTP:
# On TFTP server:
apt-get install tftpd-hpa
mkdir /srv/tftp/SOME_DIR
echo hello > /srv/tftp/SOME_DIR/FILE_NAME
# On TFTP client:
curl tftp://SERVER_IP_ADDRESS/FILE_NAME
tftp -g -r SOME_DIR/FILE_NAME SERVER_IP_ADDRESS
# FILE_NAME will be in current folder
# See logs in /var/log/syslog

# register foreign (x86-64 elf files) binary format:
echo ':qemu-x86_64:M:0:\x7F\x45\x4C\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x3E\x00:\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF:/usr/bin/qemu-x86_64:OC' > /proc/sys/fs/binfmt_misc/register

# register foreign (arm elf files) binary format:
echo ':qemu-arm:M:0:\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-arm:OC' > /proc/sys/fs/binfmt_misc/register

# Simulate root access via LD_PRELOAD:
fakeroot id
echo "id ; whoami" | fakeroot

# Create tarball for variant=fakechroot (use variant=minbase without fakechroot):
fakechroot debootstrap --arch=armhf --download-only --variant=minbase --make-tarball=debootstrap.tgz buster tmp_dir
# If tmp_dir doesn't exist - it will be created. It will be deleted at the end.

# Unpack tarball for foreign architecture:
fakeroot debootstrap --arch=armhf --foreign --unpack-tarball=debootstrap.tgz buster rootfs_dir

# Chroot to foreign architecture rootfs:
cp /usr/bin/qemu-arm-static rootfs_dir/usr/bin
mount -B /proc rootfs_dir/proc
mount -B /sys rootfs_dir/sys
mount -B /dev rootfs_dir/dev
mount -B /dev/pts rootfs_dir/dev/pts
# grep for "mount -t proc" and "mount -t sysfs" in rootfs_dir/debootstrap
# and comment these mounts out.
chroot rootfs_dir

# Complete debootstrap in chroot (do second stage):
/debootstrap/debootstrap --second-stage

# Download and install (first stage only):
fakeroot debootstrap --arch=armhf --foreign buster mnt
# Chroot without root privileges:
fakechroot chroot root_dir
fakechroot chroot root_dir CMD
echo "CMD1 ; CMD2" | fakechroot chroot root_dir
# Transparent cross-compilation (your cross-compiler will be accessed via /usr/bin/gcc):
# Initialize a target (need to be executed just once, TARGET may be any string):
sb2-init -d -n TARGET CROSS_COMPILER
sb2 # -eR # Enter scratchbox environment
fakeroot debootstrap --arch=armhf --foreign --variant=minbase buster DIR
# Here DIR is a directory you've executed sb2-init in (be carefull with symlinks).

# Generate password for /etc/passwd:
openssl passwd -1 -salt my_salt my_password
# -1  Use the MD5 based BSD password algorithm 1.
#
# Second field in /etc/passwd: "password":
# <hash> - User can login with appropriate password.
# <empty> - Empty password (just press enter to login).
# x - Encrypted password is available in /etc/shadow.
# * - From man passwd: the user will be unable to login using login(1), but may
#     still login using rlogin(1), run existing processes and initiate new ones
#     through rsh(1), cron(8), at(1), or mail filters, etc. Trying to lock an
#     account by simply changing the shell field yields the same result and
#     additionally allows the use of su(1).
# ! - Password cannot be used (locking / disabling / suspending a user account).
#     It is essentially an invalid hash - something that can't be reached with
#     any password input.
#     Remaining characters after '!' are a password before it was locked.
#     Note: if you wish to lock the account (not only access with a password),
#     you should also set the EXPIRE_DATE to 1.
# !! - Same as ! (see above).
#
# Add 'root' user with password 'my_password':
echo "root:$(echo 'my_password' | mkpasswd --salt=MyLongSalt --method=sha-512 -s):0:0:Root,,,:/:/bin/sh" >> /etc/passwd

# man for openssl command (enc, passwd, ...):
man 1ssl cmd

# View current kernel config:
zcat /proc/config.gz

# Note: for debug logging better use normal printk().
# debug printk:
pr_devel() should produce zero code unless DEBUG is defined
# printk(KERN_DEBUG "fmt", ...)
# printk "array" format specifier: %5ph - print 5 bytes in hex.
# printk "function pointer" format specifier: Documentation/core-api/printk-formats.rst
# For dynamic debugging:
pr_debug(char *format, ...);
# To enable output from pr_debug() for kobject_uevent.c:
CFLAGS_kobject_uevent.o := -DDEBUG
# If you are writing a driver, please use dev_dbg instead
dev_dbg(struct device *dev, char *format, ...);
# add '#define DEBUG' as a first line of file to be debugged
# See also: BUG(), BUG_ON(), dump_stack()

# Usefull linux kernel command line (cmdline) args:
# Set log buffer (dmesg) size:
log_buf_len=n # Here "n" is a power of 2 number

# Get linux kernel printk ring buffer address (in hex):
readelf -s vmlinux | grep __log_buf | cut -d: -f2 | cut -d' ' -f2
# See also $DOTRC/bin/uboot_mem_dump_extract_strings.sh

# Enable all (debug-level) messages:
echo 7 > /proc/sys/kernel/printk
# in linux command line:
loglevel=8
# or
ignore_loglevel

# Show dmesg log:
dmesg -w
tail -F /var/log/messages
tail /var/log/syslog
tail /proc/kmsg
tail /dev/kmsg
# See also file:
/proc/sys/kernel/printk
# See all printk() messages independent of level:
echo 8 > /proc/sys/kernel/printk

cat /proc/interrupts

# Write to physical memory:
#       address   size_in_bits value
devmem 0xfd000010      16       0x3f

# Linux kernel usefull debug functions:
if (error && printk_ratelimit())
    printk(KERN_EMERG “error=%d\n”, error);
BUG_ON(condition)
if (something_bad_happened)
    BUG();
dump_stack(); // linux kernel print (dump, trace) stack
trace_dump_stack(0); // ftrace
panic("terrible_thing is %ld!\n", terrible_thing);

# see gdb linux kernel hardware (hw) breakpoint support (debug):
CONFIG_HAVE_HW_BREAKPOINT

# Linux kernel debugging (see also linux/Documentation/features/debug):
1) gdb vmlinux /proc/kcore
# Note: gdb caches variables. To reset gdb cache use the following gdb command:
core-file /proc/kcore
To debug kernel modules need to specify load address for sections.
See file "/sys/module/MODULE_NAME/sections" for sections base addresses.
Use gdb command:
add-symbol-file /path/to/my_module.ko $TEXT_SECTION_ADDRESS \
-s .bss $BSS_SECTION_ADDRESS -s .data $DATA_SECTION_ADDRESS
where addresses look like: 0x12345678
2) CONFIG_KGDB=y, CONFIG_FRAME_POINTER=y, CONFIG_KGDB_SERIAL_CONSOLE=y
   Debug with gdb over serial port (kgdboc) / ethernet (kgdboe)
   Note: some ethernet drivers are so complex with separate kernel thread that
   the polled mode ethernet can hang due to locking or unsafe HW resource access.
   If you really want to attempt use kgdboe successfully, use a dedicated
   interface if you have one and do not use kernel soft or hard IRQ preemption.
   kgdboc is slow but the most reliable.
     # On PC: download and build agent-proxy (debug splitter, allows to share a
     # serial port for both text console and gdb debug session):
     git clone http://git.kernel.org/pub/scm/utils/kernel/kgdb/agent-proxy.git
     cd agent-proxy
     make
     # On PC: start agent-proxy (minicom should be already closed):
     ./agent-proxy 5550^5551 0 /dev/ttyUSB0,115200
     # On PC: get text console (shell on device to be debugged):
     telnet localhost 5550
     # On device to be debugged: run linux kernel with "kgdboc=ttyS1,115200"
     # command line argument, see also: /sys/module/kgdboc/parameters/kgdboc
     # On device to be debugged: enter kgdb debug mode:
     echo g > /proc/sysrq-trigger
     # On PC:
     cat << EOF > /tmp/gdb_script
     # Load linux kernel ELF file with debug info (see linux kernel debug
     # configuration options below):
     file /media/files/workspace/linux/vmlinux
     target remote localhost:5551
     bt
     EOF
     gdb-multiarch -x /tmp/gdb_script
   Files:
   Documentation/sysrq.txt
   /proc/sys/kernel/sysrq
   echo g > /proc/sysrq-trigger
   SysRq = print screen key on keyboard
   Key sequence: "press Alt", "press SysRq", "release SysRq",
   "press <command key>", release everything.
3) CONFIG_KGDB_KDB=y, CONFIG_KDB_KEYBOARD=y
   Press pause/break on console to start a debugger.
4) Linux Trace Toolkit (LTT)
5) Dynamic Probes

# mount debugfs (ftrace):
mount -t debugfs none /sys/kernel/debug

# mount devtmpfs (/dev):
mount -t devtmpfs none /dev

# mount procfs (/proc):
mount -t proc none /proc

# mount sysfs (/sys):
mount -t sysfs none /sys

# Linux kernel find driver that controls /dev/* (devtmpfs) file:
# determine major number by running:
ls -l /dev/some_device
# Now explore sysfs at:
/sys/dev/{char,block}/{major_number}

# Linux kernel debug configuration options (see "kernel hacking" menu):
CONFIG_DEBUG_KERNEL=y
CONFIG_DEBUG_INFO=y
CONFIG_FRAME_POINTER=y
CONFIG_KALLSYMS=y
CONFIG_DEBUG_RODATA=n # allow use of software breakpoints
# some other usefull configuration options:
CONFIG_PROFILING=y
CONFIG_DEBUG_DRIVER=y
CONFIG_PREEMPT=y
CONFIG_DEBUG_SPINLOCK_SLEEP=y

# Linux kernel memory errors detection (debugging):
CONFIG_KMEMCHECK=y
CONFIG_DEBUG_KMEMLEAK=y
CONFIG_DEBUG_VM=y
CONFIG_DEBUG_PAGEALLOC=y
# Kernel Address Sanitizer (KASAN).
# (since v4.0, see: 0b24becc810dc3be6e3f94103a866f214c282394)
# Architectures supported: arm64, x86, xtensa
CONFIG_KASAN=y
# linux kernel debug slab, slub slob (kfree, kmalloc):
CONFIG_SLUB=y
CONFIG_SLUB_DEBUG=y
CONFIG_SLUB_DEBUG_ON=y
# See: include/linux/poison.h
#define PAGE_POISON 0xaa // marked with this value after free(). Warning: it is not changed by alloc()
#define SLUB_RED_INACTIVE 0xbb
#define SLUB_RED_ACTIVE 0xcc
#define POISON_INUSE 0x5a /* for use-uninitialised poisoning */
#define POISON_FREE 0x6b /* for use-after-free poisoning */ // right after kmalloc()
#define POISON_END 0xa5 /* end-byte of poisoning */

# Linux kernel ftrace configuration options:
CONFIG_FTRACE
CONFIG_FUNCTION_TRACER
CONFIG_FUNCTION_GRAPH_TRACER
CONFIG_STACK_TRACER
# sysctl kernel.stack_tracer_enabled
CONFIG_DYNAMIC_FTRACE
CONFIG_FUNCTION_PROFILER

# Using ftrace:
# sudo perf ftrace -a # see also systemtap (for profiling)
# trace_printk() can be called from any context (interrupts, scheduler, ...).
# It prints to /sys/kernel/debug/tracing/trace
trace_dump_stack(0);
cat /sys/kernel/debug/tracing/available_tracers
echo function > /sys/kernel/debug/tracing/current_tracer
# For x86 only:
echo mmiotrace > /sys/kernel/debug/tracing/current_tracer
# Use case:
if ! mount | grep /sys/kernel/debug/tracing 1>/dev/null ; then
    mount -t debugfs none /sys/kernel/debug
fi
echo 0 > /sys/kernel/debug/tracing/tracing_on
echo function_graph > /sys/kernel/debug/tracing/current_tracer
echo 1 > /sys/kernel/debug/tracing/free_buffer
echo 100000 > /sys/kernel/debug/tracing/buffer_size_kb
echo 1 > /sys/kernel/debug/tracing/tracing_on
echo "my tracing start" > /sys/kernel/debug/tracing/trace_marker
run_test
echo "my tracing end" > /sys/kernel/debug/tracing/trace_marker
echo 0 > /sys/kernel/debug/tracing/tracing_on
# Non-consuming read:
cat /sys/kernel/debug/tracing/trace
# Consuming read:
cat /sys/kernel/debug/tracing/trace_pipe

# See also:
cat /sys/kernel/debug/tracing/README
cat /sys/kernel/debug/tracing/available_filter_functions
# Show only when SyS_read() is started and finished (no trace inside):
echo SyS_read > /sys/kernel/debug/tracing/set_ftrace_filter
# Show SyS_read() call graph (trace inside):
echo SyS_read > /sys/kernel/debug/tracing/set_graph_function
# Show full trace:
echo > /sys/kernel/debug/tracing/set_ftrace_filter

# Truncate file:
truncate -s SIZE FILE

# View file sizes (right one is apparent size = including holes):
ls -lsh FILE
ls -ls --block-size=1 FILE

# Resize ext2/3/4 partition:
e2fsck -f FILE
resize2fs -p FILE [SIZE]

# Check filesystem for errors (do not correct anything):
fsck.reiserfs -n FILE

# Do not reserve 5% of space on file system:
mkfs -t ext4 -m 0 -L files_partition /dev/sdX1
tune2fs -m 0 FILE

# To apply patches manually:
1. Copy debian folder to original sources
2. export QUILT_PATCHES=debian/patches
3. cd original_sources_root_folder && quilt push -a

# To unapply debian patches (see also quilt applied/unapplied):
quilt pop -a

# Manual patching (according to order in "series" file):
patch --no-backup-if-mismatch -p1 < $SOME_PATH_PREFIX/debian/patches/PATCH_NAME.patch

# To generate package description file (.dsc):
(needed: root/PACKAGE_ROOT/debian, root/original_sources.tar.*):
cd root && dpkg-source -b PACKAGE_ROOT

# Create patch file (use diff -uNr for directories):
diff -uN old_file new_file > patch_file

# Apply patch:
patch old_file patch_file
cd destination_dir && patch -p1 < ../patch_file
# Do not ask anything, do not create .orig and .rej files:
patch -f -r - --no-backup-if-mismatch old_file patch_file

# git clone all submodules:
git clone --recurse-submodules URL

# git checkout saved in main repo submodule commits (hashes):
git submodule update

# git diff in all submodules:
git submodule foreach git diff --color=always | cless

# git submodules clean:
git clean -ffdx
git submodule update --init --recursive

# Make git command working with submodules by default:
git config submodule.recurse true

# Select branch to track for "git submodule update --remote":
# git config -f .gitmodules submodule.SUBMODULE_NAME.branch BRANCH_NAME

# pull main repo and all submodules:
git pull --recurse-submodules

# check that all submodules are pushed before pushing main repo:
git push --recurse-submodules=check
# Set it by default: git config push.recurseSubmodules check

# git find common ancestor (parent) for two (2) branches:
git merge-base branch1 branch2

# git list branches (check) that contain specified commit:
git branch --all --contains SHA1

# git check whether child commit has some parent (ancestor) commit:
git rev-list child | grep parent

# git show last commits date in all branches (track recent development):
for branch in `git branch -r | grep -v HEAD`;do echo -e `git show -s --format="%ci %cr" $branch` $branch; done | sort -r

# git list/check tags that contain specified commit:
git tag --contains SHA1

# git add new checkout
git worktree add /path/to/non/existent/directory

# git show new commits on upstream for a given branch:
git fetch REMOTE
git log BRANCH..REMOTE/BRANCH

# git show all not pushed commits:
git log --branches --not --remotes --graph --decorate

# git change remote (upstream) url:
git remote set-url REMOTE URL

# git fetch only one commit:
# on server side:
git config --local uploadpack.allowReachableSHA1InWant true
# on client side:
mkdir repo_root
cd repo_root
git init
git remote add origin URL
git fetch --depth 1 origin COMMIT_SHA
git checkout FETCH_HEAD

# Create new branch and specify tracking information:
git checkout -b master --track origin/master

# git list tags ordered by date:
git log --tags --simplify-by-decoration --pretty="format:%ci %d"

# git show config options:
git config --list

# Rebase by default when doing git pull:
git config branch.master.rebase true

# git config unset option:
git config --unset OPTION

# git show last 4 commits (only hashes):
git log HEAD@{3}..HEAD --pretty=format:"%H"

# Process last 4 commits one by one:
(git log HEAD@{3}..HEAD --pretty=format:"%H" && echo) | while read commit ; do echo "commit = $commit" ; done

# git blame further (deeper) in history:
git blame COMMIT~1 FILE

# git blame deleted line:
git log -S part_of_deleted_string path/to/file

# git blame deleted file:
git log -- path/to/file

# git delete non-existend (obsolete, stale) remote branches:
git remote prune REMOTE
# git get list of commits in BRANCH since COMMIT_1:
git rev-list ^COMMIT_1 BRANCH

# git change email:
git config user.email 'your_email@gmail.com'
# git change email: add in .git/config:
[user]
        email = your_email@gmail.com

# git show parent commits (parents):
git log --pretty=%P -n 1 HEAD

# git delete remote branch (from remote repository):
git push REMOTE --delete BRANCH
git push REMOTE :BRANCH

# git repository as shared folder:
# Write:
git push -f REMOTE BRANCH
# Read:
git fetch REMOTE
git checkout -B BRANCH
git reset REMOTE/BRANCH --hard

# To revert branch from some commit, first find a commit in logs:
cat REPO_ROOT/.git/logs/refs/heads/*
# Create new branch pointing to this commit:
git checkout -b BRANCH_NAME SHA

# Stash (including untracked files):
git stash -u
# Pop stash (do not unstage):
git stash pop --index
# Show stash contents:
git stash show -p [stash@{1}]

# Create patch file:
git format-patch -1 [-o OUT_DIR] [SHA]
# Apply patch file:
cd GIT_ROOT_DIR
git apply PATCH_FILE
# Apply patch file and create commit based on it:
git am < PATCH_FILE

# git change author of commit:
git commit --amend --reset-author
git commit --amend --author "New Author Name <email@address.com>"

# create bundle:
git bundle create BUNDLE_FILE COMMIT_FROM..COMMIT_TO
# verify bundle:
git bundle verify BUNDLE_FILE
# view current remotes:
git remote [-v]
# add bundle as remote:
git remote add REMOTE_NAME BUNDLE_FILE
# delete remote:
git remote remove REMOTE_NAME
# fetch new remote:
git fetch REMOTE_NAME

# View branches tracking information:
git branch -vv
# Add tracking information to git branch:
git branch -u origin/remote_branch [local_branch]
# The same for git 1.7 (old):
git branch --set-upstream local_branch origin/remote_branch

# .gitignore file in .git folder:
.git/info/exclude

# do not track changes in commited file:
git update-index --assume-unchanged FILE

# push HEAD to remote_branch:
git push origin HEAD:remote_branch

# push all except last commit to upstream:
git push origin HEAD~1:BRANCH

# Show all files, affected by a given commit:
git diff-tree --no-commit-id --name-only -r COMMIT
git show --name-only COMMIT
# Show changes introduced by a commit in a single given file:
git show COMMIT FILE
# Show all commits that changed given file:
git log --follow FILE

# Git do not verify ssl certificates (https):
git config [--global] http.sslVerify false
GIT_SSL_NO_VERIFY=true git clone URL
git -c http.sslVerify=false clone URL
# Git use custom certificate:
git config [--global] http.sslCAInfo FILE.cer
GIT_SSL_CAINFO=FILE.cer git clone URL
git -c http.sslCAInfo=FILE.cer clone URL

# Add all untracked files:
git add -A

# gerrit udpate commit (patch set):
git push origin HEAD:refs/changes/CHANGE_NUMBER

# Gerrit commit:
git push origin HEAD:refs/for/BRANCH_NAME

# Show changes in the cache/index (i.e. staged chenages) against the current HEAD:
git diff --name-only --cached

# Show commit statistics (lines changed / removed / deleted / added):
git diff --shortstat HEAD~1 HEAD
git diff --stat HEAD~1 HEAD
git log --stat
git log --numstat

# Git amend not last commit:
git rebase --interactive bbc643cd^
# In the default editor, modify 'pick' to 'edit' in the line whose commit you want to modify
edit FILES_TO_MODIFY
git add FILES_TO_MODIFY
git commit --amend --no-edit
git rebase --continue

git log --graph --pretty=format:"%d %h %ai %an %s"
git log --graph --all --decorate

# rsync example:
rsync -avP --delete --exclude=.git/* --exclude=obj/* --exclude=*.opendb --exclude=.vs/* SRC_DIR DESTINATION_DIR

# Alsa sound recording (tee plugin):
aplay -v -Dtee:\'plughw:0,0\',./raw_samples_file,raw FILE.wav
# Alsa play recorded sound:
aplay -v -c 2 -f S16_LE -r 44100 ./raw_samples_file

# Play sound via specific sound device:
aplay -D hw:#CARD,#DEVICE,#SUBDEVICE FILE.wav

# Alsa commands:
cat /proc/asound/cards (modules, devices)
aplay -v file.wav

# Who uses file/folder:
fuser FILE
fuser -m FOLDER

# Show session IDs and process group IDs:
ps -eo sid,pgid,ppid,pid,comm

# Show all processes and threads:
ps -efL

# Show process hierarchy (forest):
ps -efH

# Get process parent:
ps -o ppid= -p CHILD_PID
cat /proc/CHILD_PID/status | grep PPid | cut -f2

# rpm print macro definition:
rpm --eval "%{_prefix}"

# List all filesystems, devices backed by them, mount points:
findmnt

# trace execve syscalls (including child processes):
strace -f -s 8192 -o trace_file -e trace=execve CMD
# attach to process and begin tracing:
strace -p PID

# P4 help:
p4 help COMMAND

# P4 changelist:
# P4 view changelists, integrated into specified file(s):
p4 changes -i REMOTE_FILE
p4 changes -i REMOTE_FOLDER/...

# P4 list of pending changelists:
p4 changes -s pending -u USER_NAME -c WORKSPACE_NAME

# P4 create new changelist:
cat CHANGELIST_DESCRIPTION_TXT | p4 change -i

# P4 edit existed changelist:
p4 change -O changelist#

# P4 view changelist:
p4 change -o
p4 change -o -O changelist#
p4 describe changelist#
p4 files @=changelist#

# P4 submit changelist:
p4 submit [-r -f] -c changelist#

# P4 delete changelist:
p4 change -d changelist#

# P4 workspace:
# P4 list all workspaces, owned by USER_NAME:
p4 clients -u USER_NAME

# P4 switch to a workspace:
export P4CLIENT=WORKSPACE_NAME

# P4 print current workspace settings:
p4 client -o

# P4 create workspace:
cat WORKSPACE_SETTINGS_TXT | p4 client -i

# P4 delete workspace:
p4 client -d WORKSPACE_NAME

# P4 get latest revision:
p4 sync
p4 sync -f //depot/path/to/folder/...#head

# P4 remove all files from workspace:
p4 sync /path/to/local/workspace/...#0

# P4 file/folder operations:
# P4 view opened files:
p4 opened
p4 opened -a

# P4 mark file for deletion:
p4 delete -c changelist# -v //depot/path/to/file

# P4 mark folder for deletion:
p4 delete -c changelist# -v //depot/path/to/folder/...

# P4 revert file:
p4 revert //depot/path/to/file

# P4 revert folder:
p4 revert //depot/path/to/folder/...

# P4 mark file for add:
p4 add -c changelist# /path/to/local/file

# P4 mark folder for add:
p4 add -c changelist# '/path/to/local/folder/*'

# P4 mark file for edit (checkout):
p4 edit -c changelist# /path/to/local/file

# P4 mark folder for edit (checkout):
p4 edit -c changelist# /path/to/folder/...

# P4 rename file:
p4 edit -c changelist# /path/to/local/file/before
p4 move /path/to/local/file/before /path/to/local/file/after
In changelist:
	//depot/path/to/remote/file/before	# move/delete
	//depot/path/to/remote/file/after	# move/add

# Output lines [K; L]
tail -n +K | head -n {L - K + 1}

# Output lines [1; K]
head -n K

# Output lines [K; EOF)
tail -n +K

# Documentation browser: zeal (depends on latest qt5)

# Man pages local path:
/usr/share/man
# Find a package, MAN_PAGE belongs to:
apt-file search -x 'man[0-9]/MAN_PAGE.*\.gz'

# Search man pages description for keyword:
apropos KEYWORD
man -k KEYWORD

# Search man pages contents for keyword:
man -K -w KEYWORD

# Get DPI (dots per inch):
xdpyinfo | grep resolution

# to exit telnet:
ctrl+] and afterwards ctrl+d

# Qemu monitor:
qemu-system-arm -monitor pty
> pid 23969's current affinity mask: ff
> pid 23969's new affinity mask: 1
> char device redirected to /dev/pts/4 (label compat_monitor0)
screen /dev/pts/4
minicom -p /dev/pts/4

# Connect to serial port:
sudo minicom -b 115200 -t xterm -D /dev/ttyUSB0

# minicom configuration:
<ctrl>+A <pause> O  -> serial port setup -> hardware flow control
(set to Novia "F" key)
than go to main menu, select "Save setup as dfl"

# Exit minicom:
<ctrl>+A <pause> X

# Freeze screen in minicom:
<ctrl>+A
# Continue printing in minicom:
ESC

# Start screen:
screen /dev/ttyUSB0 115200N1
screen

# Detach from screen:
<ctrl>a + d

# Create new screen session or attach to existing ones (if present):
screen -d -R

# Resume detached screen session:
screen -r <TAB>

# Exit from screen:
<ctrl>a + :quit

# QEMU save memory:
pmemsave <address> <size> <file>

# Qemu interaction:
<Ctrl> + A     <pause>     H

# Exit qemu:
<Ctrl> + A     <pause>     X

# Switch to qemu's console:
<Ctrl> + A     <pause>     C

# Select alternative c++ standard library:
# LLVM C++ Standard library:
g++ -stdlib=libc++ FILE.cpp
# GNU Standard C++ Library (default):
g++ -stdlib=libstdc++ FILE.cpp

# enable failures in libc via LD_PRELOAD (fiu):
fiu-run -x -c 'enable name=posix/io/*' ls

# Run arm executable using qemu-arm:
sudo apt-get install gcc-4.7-arm-linux-gnueabi # arm cross compiler
sudo apt-get install libc6-dev-armel-cross # arm C library development files
arm-linux-gnueabi-gcc -static 1.c
qemu-arm a.out

# Extract .jar file (java library):
jar xf FILE.jar

# Disassemble .class file (java):
javap -p FILE.class

# Measure disk speed:
sudo hdparm -t DEVICE

# Install nfs server:
sudo apt-get install nfs-kernel-server
# Rootfs via nfs - kernel cmdline options:
KERNEL_CMDLINE:root=/dev/nfs nfsroot=192.168.1.1:/path/to/rootfs_mnt rw ip=dhcp console=ttyS0,115200n8 sdp_hwaddr=SOME_MAC
# Restart nfs service:
service nfs-kernel-server restart
# nfs server config (/etc/exports):
/path/to/rootfs_mnt *(rw,sync,no_root_squash,no_subtree_check)

# Show video mode resolution ModeLine:
xvidtune -show

# Display total size of current directory:
du -h -s
# Display size of each direcory inside current ones:
du -h -d 1

# Mount usb so that all users can write to it:
su -c 'mount -ouser,umask=0000,exec /dev/sdb1 /media/USB'

# Replace symbol (space in this case) witn \n:
cat FILE_BEFORE | tr ' ' '\n' > FILE_AFTER

# Print keymap table:
xmodmap -pk
xmodmap -pke

# map Escape to CapsLock:
xmodmap -e 'clear Lock' -e 'keycode 0x42 = Escape'

# Use setxkbmap to remap keys:
setxkbmap -option OPT
# Where OPT can be:
caps:none          # Disables Caps Lock.
caps:super         # Caps Lock becomes an additional Super (aka Win key).
caps:ctrl_modifier # Caps Lock becomes an additional Ctrl.
caps:numlock       # Caps Lock becomes an additional Num Lock.
caps:escape        # Caps Lock becomes an additional Escape.
caps:backspace     # Caps Lock becomes an additional Backspace.
caps:swapescape    # Caps Lock becomes Escape, and Escape becomes Caps Lock

# Print contents of X events (and keyboard codes):
xev

# Canonicalize PATH:
readlink -f PATH
realpath PATH

# Convert raw framebuffer data to png image:
ffmpeg -vcodec rawvideo -f rawvideo -pix_fmt rgb32 -s 1920x1080 -i FRAMEBUFFER.DUMP -f image2 -vcodec png framebuffer.png

# Cut mp3 [00:00; 00:16]:
avconv -i input.mp3 -codec copy -ss 00:16 out.mp3
# Cut mp3 [00:16; 00:26]:
avconv -i input.mp3 -codec copy -ss 00:16 -t 00:10 out.mp3

# extract audio (mp3) from video:
avconv -i video.mp4 -q:a 0 -map a audio.mp3

# less search command line:
less -p pattern FILE

# get timestamp
ls -l --time-style=+%s <FILE | FOLDER> | cut -d' ' -f 6

# Get squashfs compression algorithm:
unsquashfs -s rootfs.img | grep Compression

# grep recursively by file extension:
grep -R --include=*.cpp --include=*.h --exclude=*.inl.h <pattern> .

# Show only file names with matched content:
grep -rl -m 1 'REGEX' .

# C++ ABI version:
readelf -V file.elf | grep CXXABI_

# dwarf debug information (tags: gcc, gdb, elf):
readelf --debug-dump=info FILE
objdump -g FILE

# All info elf:
readelf -a FILE

# Check debug info (debug symbols, debug sections) in elf:
readelf --sections FILE | grep debug
# always present: .debug_aranges, .debug_info, .debug_abbrev, .debug_line, .debug_ranges
# -g  adds: .debug_frame, .debug_str
# -g3 adds: .debug_macro
# Sometimes sections .debug_frame, .debug_str and .debug_macro are present but
# file doesn't contain debug information anyway. More precise: readelf --debug-dump=info

# Dynamic (elf file ) dependencies (shared libraries, elf file):
readelf -d FILE | grep NEEDED
objdump -p FILE | grep NEEDED
ldd FILE # doesn't work for other architecture (always returns not a dynamic executable)
LD_TRACE_LOADED_OBJECTS=1 /lib/ld-linux.so.3 FILE

# Convert address in ELF file into source file and line number within it:
addr2line -e ELF_FILE 0x20015678

# 7z decompressing:
7z x FILE.7z
p7zip -d FILE.7z

# 7z compressing:
7z a FILE.7z /path/to/folder
7z a -t7z -v89m -mx0 -r FILE.7z /path/to/folder

# Determine sectors occupied by a given file:
sudo hdparm --fibmap FILE

# View dot files:
xdot file.dot (or better file.gv)

# Trace32 commands:
break.set 0x12345678
data.load.elf <elf file> /nocode
data.load.binary <binary file> 0x12345678
data.dump 0x12345678
break.set 0x12345678 /condition register(r0)==0x12345678
go.till register(r0)==0x12
r.s r4 <value>

# Core dump:
# CONFIG_COREDUMP=y
# grep core_pattern linux_src/Documentation/sysctl/kernel.txt
# cat /proc/sys/kernel/core_pattern
# man core
# man bash # search for ulimit
echo "core.dump.%e.%p" | sudo tee /proc/sys/kernel/core_pattern
ulimit -c unlimited
ulimit -a
# now launch executable crashed..

# Restore deleted file:
mkdir restore
sudo extundelete --restore-file other/commands -o restore /dev/sda5

# Linux kernel objdump
arm-linux-gnueabi-objdump -D -b binary -m arm Image

# Mount initrd:
sudo mount -o loop -t sysfs /boot/initrd.img-3.11.0-12-generic <mount point>

# mount iso file:
fuseiso <image_file> <mount_point>
fuseiso --help
fusermount -u -z <mount_point> # unmount

# Turn screen off (without blocking):
xset dpms force off

# Code formatting (eclipse):
<Ctrl> + I

# Display stack size
ulimit -all
man 2 getrlimit

# Print hex dump (format - big endian):
xxd
# Format: 7A123456 (4 byte long values, native endianess = little):
hexdump -v -e '/4 "%08X\n"' FILE
# Format: 0000461f:   D5
hexdump -v -e '/1 "%08_ax:   "' -e '/1 "%02X\n"' FILE
# Format: C array: 0x0A, 0x69
hexdump -v -e '/1 "0x%02X, "' FILE
# Format: shell string of hex-encoded characters: \x0A\x69
hexdump -v -e '"\\" /1 "x%02X"' FILE
# Format: space-delimited bytes in hex: 0A 69
hexdump -v -e '" " /1 "%02X"' FILE

# Assembler thumb code:
".code 16\n\t"
".arch armv5te\n\t"

# "adb remount" from android device terminal (su required):
mount -r -w -o remount /system /system
mount -o rw,remount /

# assemble jump instruction (0x848a <main+10>:	bl	0x84dc):
bl m1
.skip 0x84dc - 0x848a - 4
m1:

# ARM, THUMB opcodes
binutils-2.23.2/opcodes/arm-dis.c
binutils-2.23.2/include/opcode/arm.h

# Scan for network devices (port will be blocked):
sudo arp-scan --interface=eth0 --localnet

# Add route (tags: network, table):
sudo ip r add 192.168.2.1 via 192.168.1.1 dev enx00249b20423d
# Delete route:
sudo ip r del 192.168.2.1

# Measure network performance / throughput:
# on server:
iperf3 -s
# on client:
iperf3 -c SERVER_IP [-R] [-t10] [-u -b 100M]

# Internet fixing commands:
mtr --report-wide --show-ips --report-cycles 100 8.8.8.8
nm-tool
tracepath
traceroute
route # get default gateway
cat /etc/resolv.conf
/etc/network/interfaces

# Partitions details:
ls /dev/disk/by-uuid
sudo blkid /dev/sda6
lsblk

# Linux directories rights access:
# If no access to file then open() syscall fails.
# Hard link- completely another file.
# Symbolic link - just a reference to real file.
# Folder read access:    can't open files (can't read, can't write), can't cd to folder,
#                        can ls folder contents (only file/folder names, no details)
# Folder execute access: can open files (read/write permissions depend on file permissions),
#                        can cd to folder, can't ls folder contents.
# Folder write access:   can create new files,
#                        can delete existed ones if execute folder access available.

# Check whether swap is enabled (empty output means "no swap"):
swapon --show

# Format partition as a swap:
mkswap -L linux_swap /dev/sdaX

# Create swap file and use it (execute as root):
fallocate -l 8G /swapfile
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile

# update-alternatives:
ls -l /etc/alternatives
update-alternatives --query x-window-manager
update-alternatives --set x-window-manager $(which i3)

# Get audio/video file info (package libav-tools needed):
avprobe file.avi

# Brightness on samsung laptop:
# current brightness:
/sys/class/backlight/intel_backlight/brightness
# maximum brightness:
/sys/class/backlight/intel_backlight/max_brightness

# Add ppa to /etc/apt/sources.list (debian):
deb http://ppa.launchpad.net/colingille/freshlight/ubuntu lucid main

# Create usb to install Windows 7 (without grub):
dd if=/dev/zero of=/dev/sdX count=3000
fdisk /dev/sdX
mkfs -t ntfs -f -L windows_7 /dev/sdX1
# Copy files:
mount /dev/sdX1 /mnt/usb_mnt
mount windows_7.iso /mnt/windows_iso
cp -r /mnt/windows_iso/* /mnt/usb_mnt/
umount /mnt/usb_mnt
# Fix MBR (add bootstrap code):
wget https://www.kernel.org/pub/linux/utils/boot/syslinux/syslinux-6.01.tar.xz
dd if=syslinux-6.01/bios/mbr/mbr.bin of=/dev/sdX
sync
# For grub2 version syslinux is not necessary (see $DOTRC/other_files/grub.cfg)

# Create bootable usb (grub2):
dd if=/dev/zero of=/dev/sdX bs=1k count=1
fdisk /dev/sdX
mkfs -t vfat -F 32 -n USB_BOOT /dev/sdX1
mount /dev/sdX1 /mnt
apt-get install grub2-common
# grub-install --target=x86_64-efi --efi-directory=/boot/efi --boot-directory=/mnt/boot /dev/sdX
apt-get install grub-pc-bin && grub-install --target=i386-pc --boot-directory=/mnt/boot /dev/sdX
edit /mnt/boot/grub/grub.cfg
# Add memdisk (to boot iso/floppy/hard disk images):
wget https://www.kernel.org/pub/linux/utils/boot/syslinux/syslinux-6.01.tar.xz
cp syslinux-6.01/bios/memdisk/memdisk /mnt/boot/memdisk
# Add mhdd:
wget http://www.ihdd.ru/download/software/mhdd/mhdd32ver4.6iso.zip
cp mhdd32ver4.6.iso /mnt/boot/mhdd.iso
# Add memtest:
wget http://www.memtest86.com/downloads/memtest86-iso.gz
cp memtest86-iso /mnt/boot/memtest.iso
# See $DOTRC/other_files/grub.cfg
umount /mnt

# Create bootable usb (EFI):
dd if=/dev/zero of=/dev/sdX bs=1k count=1
fdisk /dev/sdX
mkfs -t vfat -F 32 -n USB_BOOT /dev/sdX1
mount /dev/sdX1 /mnt
mkdir -p /mnt/EFI/BOOT
apt-get install grub-efi-amd64-bin
grub-mkimage -o /tmp/bootx64.efi -p /boot/grub -O x86_64-efi fat iso9660 part_gpt part_msdos normal boot linux configfile loopback chain efifwsetup efi_gop efi_uga ls search search_label search_fs_uuid search_fs_file gfxterm gfxterm_background gfxterm_menu test all_video loadenv exfat ext2 ntfs btrfs hfsplus udf
cp /tmp/bootx64.efi /mnt/EFI/BOOT/
mkdir /mnt/boot/grub
edit /mnt/boot/grub/grub.cfg
umount /mnt

# Boot linux distro without GRUB (CONFIG_EFI_STUB=y in linux kernel configuration):
1) Using fdisk create GPT partition table.
2) Make first partition 512M big (minimum ~100M) and mark it as "EFI system" (code: 1).
3) Format first partition as FAT32.
4) Mount first partition to mnt.
5) mkdir -p mnt/EFI/debian
6) cp /vmlinuz mnt/EFI/debian/
7) cp initrd.img mnt/EFI/debian/
9) efibootmgr -c -L 'Debian (EFI stub)' -l /EFI/debian/vmlinuz -u 'root=/dev/sda2 add_efi_memmap initrd=/EFI/debian/initrd.img'
# In running linux:
1) Mount EFI system partition (ESP) to /boot/efi
2) See "efistub" in debian wiki
# If got EFI shell:
1) fs0:
2) edit startup.nsh
3) \EFI\debian\vmlinuz root=/dev/sda2 add_efi_memmap initrd=/EFI/debian/initrd.img
# Some usefull EFI shell commands:
bcfg boot dump
ls fs0:
fs0:
edit FILE

# efibootmgr list boot entries:
efibootmgr -v
# efibootmgr delete boot entry:
efibootmgr -b 0001 -B

# Create bootable iso image (for cdrom):
mkdir -p image_root/boot/grub
edit image_root/boot/grub/grub.cfg
apt-get install xorriso
grub-mkrescue -o grub.iso image_root

# Create hard drive (disc) image in regular file (possibly with grub):
fdisk FILE
kpartx -a FILE # add partition mappings
losetup -l # print info about loop devices
mount /dev/mapper/loop0p1 /mnt # mount first partition from FILE to /mnt
kpartx -d FILE # delete partition mappings
# losetup -f # print name of first unused loop device (for example /dev/loop0)
# losetup -o OFFSET /dev/loop0 FILE # attach loop device with regular file
# losetup -d /dev/loop0 # detach loop device from file

# Create HDD image with grub:
apt-get install kpartx grub-pc util-linux dosfstools
GRUB_CFG=grub.cfg
OUT=grub_hdd.img
MNT=/tmp/mnt
rm -f $OUT
rm -rf $MNT
mkdir $MNT
dd if=/dev/zero of=$OUT bs=1M count=10
# create a new empty DOS partition table
# add a new partition: primary, partition number = 1, default first and last sectors
# toggle bootable flag
# change partition type to "W95 FAT16 (LBA)"
# write table to disk and exit
# echo -e "o\nn\np\n1\n\n\na\nt\nc\nw\n" | fdisk $OUT
echo -e "o\nn\np\n1\n\n\na\nt\ne\nw\n" | fdisk $OUT
kpartx -a $OUT # add partition mappings:
sleep 1
PARTITION=/dev/mapper/loop0p1
mkfs -t vfat -F 16 -n GRUB_HDD $PARTITION
echo mounting...
mount $PARTITION $MNT
mkdir -p $MNT/boot
grub-install --boot-directory=$MNT/boot $OUT
cp $GRUB_CFG $MNT/boot/grub/grub.cfg
umount $MNT
kpartx -d $OUT # delete partition mappings:

# Create uImage from raw binary:
mkimage -A arm -O linux -T kernel -C none -a 0x80008000 -e 0x80008000 -n Linux-3.8.13+ -d print_hw_features.bin uImage

# Create U-Boot script image:
mkimage -A arm -O u-boot -T script -C none -n 'UbootUpdateScript' -d update_script.txt update_script.scr

# Add bridge:
brctl addbr br0
brctl addif br0 eth0

# Set mac address:
ifconfig eth0 hw ether 12:34:56:78:9a:bc
ip link set eth0 address 12:34:56:78:9a:bc

# show ipsec network packets going through the device:
ip x m

# up/down interface:
ifconfig eth0 up
ip link set wlan0 down
man ip-link

# view default route:
ip route

# Set static ip (iproute package in debian):
ip addr add 192.168.1.29/24 dev wlan0
# ifconfig wlan0 192.168.1.29/24
ip route add default via 192.168.1.1
# ip addr del 106.124.32.34/24 dev eth0

# Release current lease and stop running DHCP client:
dhclient -r

# Get ip by DHCP:
dhclient -v eth0

# DNS server:
/etc/resolv.conf

# Query DNS server and get IP address:
dig [@8.8.8.8] +short unix.stackexchange.com

# Add default gateway:
route add default gw 192.168.1.1

# Get wireless networks list:
iwlist wlan0 scan

# Connect to wireless network:
iwconfig wlan0 essid Egorator key 9173557391
# After this I'm unable to get IP by DHCP. Need to run wpa_supplicant first?

# Use ifup to configure according to /etc/network/interfaces:
ifup --all --verbose

# Wireless devices manipulation (run as root):
iw dev wlan0 <command>
commands: link, scan
iw dev wlan0 connect <SSID>

# Write file to CD-R:
genisoimage -r -J -o cd_image.iso <folder> # create iso image
# Check (paranoidal) image correctness:
sudo mount -t iso9660 -o ro cd_image.iso /media/cd_mount_point
sudo wodim -v -eject dev=/dev/sr0 /home/user/img.iso # -multi

# Launch wi-fi access point:
wifi_ap.sh -w 1+2 wlan0 eth0 AP_NAME PASSWORD

# use backtrace(3) with addr2line(1):
# copy code from example in backtrace(3):
gcc -O0 -g3 backtrace_example.c -o backtrace_exe
./backtrace_exe 4 | grep -o '\[0x.\+\]' | cut -d'[' -f2 | cut -d']' -f1 | addr2line -p -f -e ./backtrace_exe

# run gdbserver:
gdbserver :PORT cmd args
gdb -> target remote :PORT

gdbserver --once --multi :PORT
gdb -> target extended-remote :PORT

# Jtag (J-Link) do not cache flash memory (gdb command):
monitor ExcludeFlashCacheRange START_ADDRESS,SIZE

# Jtag (J-Link): run gdb server:
DEVICE=ATSAM4E16E
INTERFACE=JTAG
# DEVICE=ATSAMV71Q21
# INTERFACE=SWD
/path/to/JLink_Linux_V512a_x86_64/JLinkGDBServer -device "$DEVICE" -if "$INTERFACE" -speed auto -endian little

# Jtag (J-Link): flash board:
JLINK=/path/to/JLink_Linux_V610a_x86_64/JLinkExe
JLINK_SCRIPT=/tmp/flash_board_sh.jlink
cat << EOF > $JLINK_SCRIPT
r
loadbin $FILE_TO_FLASH 0x$FLASH_START_ADDRESS
r
exit
EOF
# SetPC 0x$PC
# h = halt, g = go, r = Reset target (RESET), ? = help
$JLINK -device $DEVICE -if $INTERFACE -speed auto -JTAGConf -1,-1 -CommandFile $JLINK_SCRIPT

# gdb:
show max-value-size
set max-value-size 100000
set breakpoint pending off

# gdb gui client:
gdbgui -g gdb-multiarch --gdb-args "-x /tmp/gdb_commands"

# prebuilt gdb toolchains for windows:
http://gnutoolchains.com/download/

# gdb redirect output to another terminal (execute "tty" to find out your tty):
gdb --tty /dev/pts/1 OTHER_ARGS

# gdb show source location
frame # <-- see current source location here
list {LINE_NUMBER|FUNCTION}
set listsize 20

# frame $(CURRENT_FRAME_NUMBER-1)
down

# frame $(CURRENT_FRAME_NUMBER+1)
up

# gdb: set environment variable:
set env VAR_NAME = VALUE

# gdb: print the full value of a C-string:
set print element 0

# gdb print array elements:
p *argv@argc

# gdb print (echo) string:
echo "some text\n"
printf "my int value = %d\n", my_value

# gdb: automatically execute some commands when breakpoint is hit:
b some_location.cpp:23
commands
p some_value
c
end

# gdb: disable "Type <return> to continue, or q <return to quit---":
set pagination off

# gdb: continue multiple times (breakpoint won't break until the Nth time it is reached):
c N

# gdb: allow pending breakpoints in gdb script:
set breakpoint pending on

# gdb: debug child process:
set follow-fork-mode child
# gdb: see also:
show follow-fork-mode

# gdb: set breakpoint on all functions:
rbreak .

# Connect to running gdbserver (gdb client):
target remote REMOTE:PORT
# Connect to running gdbserver (lldb client):
gdb-remote REMOTE:PORT

# Add symbols (gdb):
symbol-file FILE
# Add symbols (lldb):
target symbols add # TODO

# Execute debugging commands from file:
gdb -x FILE
lldb -s FILE

# gdb: (tui) refresh (redraw) screen:
refresh
CTRL-L

# gdb (tui): change window height:
winheight src 10
winheight src +1

# gdb: define command:
define cmd_name
cmd1
cmd2
end

# gdb: view next source line to to be executed:
frame

# gdb: disable overloading of c++ function names:
set overload-resolution off

# gdb: debug program with core dump:
gdb -e PROGRAM -c core.dump
gdb PROGRAM core.dump
info proc mappings
backtrace full
# in gdb:
(gdb) core-file /home/user/my_core_file

# gdb: stop on writing to stderr (x86_64 only):
b write if 2 == $rdi
# lldb: stop on writing to stderr (x86_64 only):
br s -n write -c '2 == $rdi' # TODO this is wrong
# gdb: stop on writing to stdout of some text (x86_64 only):
b write if (1 == $rdi) && (0 != strstr($rsi, "some text"))

# gdb: stop on errno modification:
watch *&errno

# gdb: stop on file open (x86_64 only):
set overload-resolution off
b open if strcmp($rdi, "/tmp/some/file") == 0

# gdb: do not stop on signal SIGUSR1 (ignore signal):
handle SIGUSR1 noprint nostop
handle SIGTRAP nostop
handle all nostop noprint

# gdb: answer "yes" on "No source file named FILE.c. Make breakpoint pending on future shared library load? (y or [n])":
set breakpoint pending on

# gdb: save value in gdb variable:
set $var_name = expression
# gdb: overwrite variable in program:
set var_name = expression

# gdb: step out of a function:
finish

# gdb: debug threads.
# Make CTRL-C / breakpoints affect only currently selected thread:
set non-stop on
# gdb: allow to control inferior in asynchronous mode:
set target-async on
# gdb: list threads:
info thread
# lldb: list threads:
thread list
# lldb: get thread name:
thread info
# gdb: switch to thread specified by a given number (ID, see "info thread"):
thread ID
# gdb: switch to thread specified by a given number (ID)
thread select ID
# gdb: interrupt current thread (doesn't work if target-async is off):
interrupt
# gdb: interrupt all threads (doesn't work if target-async is off):
interrupt -a

# gdb: write to process memory from file (read from file):
restore FILE binary START_ADDRESS_IN_MEMORY

# gdb: write to file from process memory [START .. STOP) (dump memory):
dump binary memory FILE START STOP

# gdb: catch syscall (breakpoint):
catch syscall chroot

# gdb: disable/enable breakpoints:
disable num
enable num

# gdb: conditional breakpoints (b if):
cond <bnum> <expression> # stop if <expression> == true
b LOCATION if CONDITION
ignore <bnum> <count>
# lldb: conditional breakpoints:
br s -n FUNCTION_NAME -c 'CONDITION'

# gdb: set a breakpoint for all functions matching REGEXP:
rbreak func_prefix_*

# gdb: breakpoints on read/write:
watch my_struct.some_member
watch *0xaab12450 [mask 0xfffffff0]
watch (char[100]) *0xaab12450
watch -l SomeArray[2]
# watch -  only breaks on write
# rwatch - only breaks on read
# awatch - breaks on read/write.

# gdb: delete breakpoint
del <breakpoint number>
# lldb: delete breakpoint
br de <breakpoint number>

# gdb compile code (insert, inject instructions):
cat << EOF > main.c
#include <stdio.h>
int main() {
    int i = 0;
    printf("%d\n", i);
    return 0;
}
EOF
cat << EOF > /tmp/gdb_script
file a.out
b main
run
n
compile code int j = 1; i = j; asm("nop");
c
EOF
gdb -x /tmp/gdb_script # "1" will be printed
# See https://sourceware.org/gdb/onlinedocs/gdb/Compiling-and-Injecting-Code.html#Compiler-search-for-the-compile-command
# see also "set compile-args"

# gdb: list registers
info registers
info registers all
# See also: maint print reggroups
# lldb: list registers (general-purpose)
re r
# lldb: list registers (all)
re r -a
re r rax

# gdb: list breakpoints
info break
# lldb: list breakpoints
br l

# gdb: display an array of values:
disp {$r0, $r1}

# gdb: write into memory
set *0xAb000000 = 0xcd
set {int}0xAb000000 = 0xcd

# gdb: load symbols from file
sym FILE

# gdb view source files:
info sources

# gdb: sysroot (to debug shared libraries with gdb-server):
set sysroot HOST_COPY_OF_DEBUGGIE_ROOT_WITH_LIBS_AND_LD
set solib-search-path DIR # not recommended, single step doesn't work without ld

# gdb: change sources path:
set substitute-path FROM TO

# gdb: view loaded shared libraries:
info sharedlibrary

# Generate core dump on runtime error:
ulimit -c unlimited && ./launch_buggy_program



# Core dump analysis with gdb (till end of file):



When software crashes, core dump normally appears in root folder of your
USB stick (which must be inserted in YOUR_DEVICE). Tested on blue USB 3.0 port.
Install gdb-multiarch on your Linux-powered PC:

$ sudo apt-get install gdb-multiarch

Note: you can use arm-smth-linux-gnueabi-gdb from YOUR_DEVICE toolchain but it
is not recommended, since it loads shared libraries from toolchain by default,
which differ with shared libraries used by YOUR_DEVICE software. This can lead to
confusion in case if crash appeared in shared library: gdb will display wrong
stack frames (and wrong backtrace).
Insert USB stick in your pc and copy core dump.
Extract coredump:

$ ls ~/core_dump
Coredump.executable.pid.gz
$ gunzip Coredump.EXECUTABLE_NAME.pid.gz
$ ls ~/core_dump
Coredump.EXECUTABLE_NAME.pid
$

Launch gdb-multiarch:

$ gdb-multiarch
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb)
Set architecture to ARM:
(gdb) set architecture arm
The target architecture is assumed to be arm
(gdb)

Note: this step is not required if you decided to use gdb from YOUR_DEVICE
toolchain (or any other gdb preconfigured for ARM by default).
Determine executable file which generated core dump and crash address:

(gdb) core-file Coredump.EXECUTABLE_NAME.pid
[New LWP 918]
...
[New LWP 1557]
Core was generated by `/bin/EXECUTABLE_NAME -arg1'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xa71116c0 in ?? ()
(gdb)

Now we knew that core dump was generated by /bin/EXECUTABLE_NAME and crash address is
0xa71116c0. Check whether crash was in EXECUTABLE_NAME or in some shared library:

(gdb) info proc mappings
    0xa6e8c000 0xa6e8d000     0x1000        0x0 /dev/shm/sem.AYIbvt (deleted)
...
    0xa7092000 0xa71ca000   0x138000        0x0 /bin/lib/libc-2.18.so # <- our crash address is within this range
...
    0xa71d0000 0xa71ee000    0x1e000        0x0 /bin/lib/libgcc_s.so.1
(gdb)

Now we know that crash was within libc. Note that in this case gdb still doesn't
have enough information to reconstruct backtrace (it is empty now):

(gdb) bt
#0  0xa71116c0 in ?? ()
#1  0x00000000 in ?? () # <- our backtrace should be here, however it is not yet..
(gdb)
Exit from gdb:
(gdb) q
$

Search for not stripped version of file which generated core dump. Copy it to
our "core_dump" folder:

$ cd /home/build/Perforce/dir3/dir4
$ find -type f -name EXECUTABLE_NAME
$ cp ./BIN/SymbolFiles/bin/EXECUTABLE_NAME ~/core_dump/
Make sure EXECUTABLE_NAME contain debugging info.
$ cd ~/core_dump
$ gdb-multiarch
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb) set architecture arm
The target architecture is assumed to be arm
(gdb) file EXECUTABLE_NAME
Reading symbols from EXECUTABLE_NAME...done.
(gdb) core-file Coredump.EXECUTABLE_NAME.pid
[New LWP 918]
...
[New LWP 1557]
warning: Could not load shared library symbols for 87 libraries, e.g. /dir1/dir2/libSomething.so.
Use the "info sharedlibrary" command to see the complete listing.
Do you need "set solib-search-path" or "set sysroot"?
Core was generated by `/bin/EXECUTABLE_NAME -arg1'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xa71116c0 in ?? ()
(gdb) info sharedlibrary
    No          /lib/libgcc_s.so.1
...
    No          /lib/libc.so.6 # <- our libc must be in folder "/lib" and must be named as "libc.so.6" (note that gdb command "info proc mappings" reported another path and name: "/bin/lib/libc-2.18.so")
...
    No          /lib/ld-linux.so.3
(gdb)

Search for not stripped version of libc and copy it:

$ cd /home/build/Perforce/dir3/dir4
$ find -type f -name libc.so.6
$ # <- no results, try another name:
$ find -type f -name libc-2.18.so
$ mkdir -p ~/core_dump/rootfs/lib
$ cp ./SymbolFiles/bin/lib/libc-2.18.so ~/core_dump/rootfs/lib/libc.so.6 # note: name changed from "libc-2.18.so" to "libc.so.6" 

Make sure libc contains debugging info:

$ readelf --sections ~/core_dump/rootfs/lib/libc.so.6 | grep debug
  [70] .debug_aranges    PROGBITS        00000000 13b710 00b830 00      0   0  8
  [71] .debug_info       PROGBITS        00000000 146f40 437354 00      0   0  1
  [72] .debug_abbrev     PROGBITS        00000000 57e294 0a1625 00      0   0  1
  [73] .debug_line       PROGBITS        00000000 61f8b9 0caddf 00      0   0  1
  [74] .debug_frame      PROGBITS        00000000 6ea698 0228b8 00      0   0  4
  [75] .debug_str        PROGBITS        00000000 70cf50 026d0f 01  MS  0   0  1
  [76] .debug_loc        PROGBITS        00000000 733c5f 141004 00      0   0  1
  [77] .debug_ranges     PROGBITS        00000000 874c63 02bc20 00      0   0  1
$

Libc contains debugging info.
Reload gdb and use gdb command "set sysroot" to point gdb from where to load
absolute shared library symbol files:

$ cd ~/core_dump
$ gdb-multiarch
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb) set architecture arm
The target architecture is assumed to be arm
(gdb) set sysroot rootfs
(gdb) file EXECUTABLE_NAME
Reading symbols from EXECUTABLE_NAME...done.
(gdb) core-file Coredump.EXECUTABLE_NAME.pid
warning: exec file is newer than core file.
[New LWP 918]
...
[New LWP 1557]
warning: Could not load shared library symbols for 86 libraries, e.g. /dir1/dir2/libSomething.so.
Use the "info sharedlibrary" command to see the complete listing.
Do you need "set solib-search-path" or "set sysroot"?
Core was generated by `/bin/EXECUTABLE_NAME -arg1'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  memcpy () at ../ports/sysdeps/arm/memcpy.S:202
202    ../ports/sysdeps/arm/memcpy.S: No such file or directory.
(gdb)

Note that gdb commands order matters. Please follow these steps precisely.
Check whether gdb loaded our libc:

(gdb) info sharedlibrary
                        No          /dir1/dir2/libSomething.so
...
                        No          /lib/libgcc_s.so.1
0xa70a7e70  0xa71a60f8  Yes         rootfs/lib/libc.so.6 # <- gdb has loaded our libc successfully
                        No          /lib/ld-linux.so.3
...
                        No          /lib/libflash.so
(gdb)
Now we can finally examine backtrace:
(gdb) bt
#0  memcpy () at ../ports/sysdeps/arm/memcpy.S:202
#1  0x02ce050c in some_func (param=0x50743b14, param@entry=0x50743b0c) at /home/build/Perforce/dir3/dir4/dir5/dir6/Src/dir7/Src/some_module/some_module_Init.c:150
#2  0x02ce1f00 in some_module_Init (type_disc=<optimized out>) at /home/build/Perforce/dir3/dir4/dir5/dir6/Src/dir7/Src/some_module/some_module_Init.c:1320
#3  0x02cdcd68 in dir7_Init_Disc (disc_type=<optimized out>, pLoader=<optimized out>) at /home/build/Perforce/dir3/dir4/dir5/dir6/Src/dir7/Src/dir7_Init_Disc.c:396
#4  0xb0e775c4 in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)

You can use gdb commands "bt full" and "frame" to examine stack in more detail.
If you have built YOUR_DEVICE software on build server but want to examine
backtrace on your local PC, you may encounter issue viewing source files in gdb:
(gdb) l some_func
136    /home/build/Perforce/dir3/dir4/dir5/dir6/Src/dir7/Src/some_module/some_module_Init.c: No such file or directory.

Assume you have mounted build server to your "/media/build_server" folder. To fix this issue execute gdb command "set substitute-path":
(gdb) set substitute-path /home/build/Perforce/dir3/dir4 /media/build_server/home/build/Perforce/dir3/dir4

Now you can view sources within gdb:
(gdb) l some_func
136
137    //    comment 1
138        /* hardcoding... */
139
140    //    comment 2
141        buf_smth = ctx.buf + ctx.pos_some_module;
142        pos = 0;
143
144        func1(param, buf_some_module, pos);
145        func1(param, buf_some_module, pos);
(gdb)

# Do not insert anything at the end of the file
