#include "monster_generated.h" // This was generated by `flatc`.
using namespace MyGame::Sample; // Specified in the schema.

// #include <stdio.h>
// #include <assert.h>

static void write(void **buf, size_t *buf_size)
{
    // Create a `FlatBufferBuilder`, which will be used to create our
    // monsters' FlatBuffers.
    flatbuffers::FlatBufferBuilder builder(1024);

    // flatbuffers::Offset<flatbuffers::String>
    auto weapon_one_name = builder.CreateString("Sword");

    short weapon_one_damage = 3;
    auto weapon_two_name = builder.CreateString("Axe");
    short weapon_two_damage = 5;
    // Use the `CreateWeapon` shortcut to create Weapons with all the fields set.
    auto sword = CreateWeapon(builder, weapon_one_name, weapon_one_damage);
    // flatbuffers::Offset<MyGame::Sample::Weapon>
    auto axe = CreateWeapon(builder, weapon_two_name, weapon_two_damage);

    // Serialize a name for our monster, called "Orc".
    auto name = builder.CreateString("Orc");
    // Create a `vector` representing the inventory of the Orc. Each number
    // could correspond to an item that can be claimed after he is slain.
    unsigned char treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto inventory = builder.CreateVector(treasure, 10);
    // flatbuffers::Offset<flatbuffers::Vector<unsigned char> >

    // Place the weapons into a `std::vector`, then convert that into a FlatBuffer `vector`.
    std::vector<flatbuffers::Offset<Weapon>> weapons_vector;
    weapons_vector.push_back(sword);
    weapons_vector.push_back(axe);
    auto weapons = builder.CreateVector(weapons_vector);
    // flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MyGame::Sample::Weapon> > >

    Vec3 points[] = { Vec3(1.0f, 2.0f, 3.0f), Vec3(4.0f, 5.0f, 6.0f) };
    auto path = builder.CreateVectorOfStructs(points, 2);
    // flatbuffers::Offset<flatbuffers::Vector<const MyGame::Sample::Vec3 *> >

    // Create the position struct
    auto position = Vec3(1.0f, 2.0f, 3.0f);
    // MyGame::Sample::Vec3
    // Set his hit points to 300 and his mana to 150.
    short hp = 300;
    short mana = 150;
    // Finally, create the monster using the `CreateMonster` helper function
    // to set all fields.
    auto orc = CreateMonster(builder, &position, mana, hp, name, inventory,
                            Color_Red, weapons, Equipment_Weapon, axe.Union(),
                            path);
    // flatbuffers::Offset<MyGame::Sample::Monster>

    // You can use this code instead of `CreateMonster()`, to create our orc
    // manually.
    // MonsterBuilder monster_builder(builder);
    // monster_builder.add_pos(&position);
    // monster_builder.add_hp(hp);
    // monster_builder.add_name(name);
    // monster_builder.add_inventory(inventory);
    // monster_builder.add_color(Color_Red);
    // monster_builder.add_weapons(weapons);
    // monster_builder.add_equipped_type(Equipment_Weapon);
    // monster_builder.add_equipped(axe.Union());
    // auto orc = monster_builder.Finish();

    // Call `Finish()` to instruct the builder that this monster is complete.
    // Note: Regardless of how you created the `orc`, you still need to call
    // `Finish()` on the `FlatBufferBuilder`.
    builder.Finish(orc); // You could also call `FinishMonsterBuffer(builder,
                         //                                          orc);`.

    // This must be called after `Finish()`.
    *buf = builder.GetBufferPointer();
    *buf_size = builder.GetSize(); // Returns the size of the buffer that
                                  // `GetBufferPointer()` points to.

    // FILE *f = fopen("orc.bin", "w");
    // assert(f != NULL);
    // size_t ret = fwrite(*buf, 1, *buf_size, f);
    // assert(ret == *buf_size);
    // fclose(f);
}

static void read(void *buf, size_t buf_size)
{
    // Get a pointer to the root object inside the buffer.
    auto monster = GetMonster(buf);
    // const MyGame::Sample::Monster *

    (void)buf_size;
    // `monster` is of type `Monster *`.
    // Note: root object pointers are NOT the same as `buf`.
    // `GetMonster` is a convenience function that calls `GetRoot<Monster>`,
    // the latter is also available for non-root types.

    auto hp = monster->hp();
    auto mana = monster->mana();
    auto name = monster->name()->c_str();

    auto pos = monster->pos();
    // const MyGame::Sample::Vec3 *
    auto x = pos->x();
    auto y = pos->y();
    auto z = pos->z();

    auto inv = monster->inventory(); // A pointer to a `flatbuffers::Vector<>`.
    // const flatbuffers::Vector<unsigned char> *
    auto inv_len = inv->size();
    auto third_item = inv->Get(2);

    auto weapons = monster->weapons(); // A pointer to a `flatbuffers::Vector<>`.
    // const flatbuffers::Vector<flatbuffers::Offset<MyGame::Sample::Weapon> > *
    auto weapon_len = weapons->size();
    auto second_weapon_name = weapons->Get(1)->name()->str();
    auto second_weapon_damage = weapons->Get(1)->damage();

    size_t sizeof_monster = sizeof(monster);

    printf("sizeof(monster) = %zu\n"
           "hp = %hd, mana = %hd, name = %s, pos = (%f, %f, %f),\n"
           "3rd item = %d, 2nd weapon: {name = %s, damage = %d}\n",
           sizeof_monster, hp, mana, name, x, y, z, third_item,
           second_weapon_name.c_str(), second_weapon_damage);
    // sizeof(monster) = 8
    // hp = 300, mana = 150, name = Orc, pos = (1.000000, 2.000000, 3.000000),
    // 3rd item = 2, 2nd weapon: {name = Axe, damage = 5}

    (void)inv_len;
    (void)weapon_len;

    auto union_type = monster->equipped_type();
    if (union_type == Equipment_Weapon) {
        auto equipped = monster->equipped();
        // 'const void *'
        auto weapon = static_cast<const Weapon*>(equipped);
        // Requires `static_cast` to type `const Weapon*`.
        auto weapon_name = weapon->name()->str();
        auto weapon_damage = weapon->damage();

        printf("weapon: {name = %s, damage = %d}\n", weapon_name.c_str(),
                weapon_damage);
        // weapon: {name = Axe, damage = 5}
    }
}

int main(void)
{
    void *buf;
    size_t buf_size;
    write(&buf, &buf_size);
    read(buf, buf_size);
    return 0;
}
