From: Viacheslav Volkov <viacheslav.volkov.1@gmail.com>
Subject: [PATCH] Write full path to compiler, add support for invocations like:
bear gcc file.c

---
diff --git a/libear/ear.c b/libear/ear.c
--- a/libear/ear.c
+++ b/libear/ear.c
@@ -446,6 +446,195 @@ static int call_posix_spawnp(pid_t *restrict pid, const char *restrict file,
 
 /* this method is to write log about the process creation. */
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <assert.h>
+
+struct symlink {
+    const char* full_path;
+    struct symlink* next;
+};
+
+/**
+ * @brief check whether given file is executable
+ * @param full_path [IN] - file to check
+ * @return 0 if full_path is executable regular file
+ * @return 0 if full_path is a symlink which leads to executable regular file
+ * @return errno value (>0) on system error
+ * @return -1 if file doesn't exist
+ * @return -1 if file is a broken symlink
+ * @return -2 if file is a symlink with circular dependency
+ * @return -3 if file is not executable
+ * @return -3 if file is special (neither regular file nor a symlink)
+ * @return -3 if file is a symlink which leads to special file
+ */
+static int is_executable_file(const char* full_path, struct symlink* head)
+{
+    assert(full_path != NULL);
+    assert(head != NULL);
+    assert(head->full_path != NULL);
+
+    struct stat sb;
+    errno = 0;
+    int ret = stat(full_path, &sb);
+    if (ret != 0) {
+        switch (errno) {
+            case ENOENT:
+                return -1;
+            case ELOOP:
+                return -2;
+            default:
+                ret = errno;
+                perror("stat");
+                return ret;
+        }
+    }
+    if ((sb.st_mode & S_IXUSR) == 0) {
+        /* This is not executable file. Symlink is always executable. */
+        return -3;
+    }
+
+    switch (sb.st_mode & S_IFMT) {
+        case S_IFREG:
+            return 0; /* this is the file we are looking for */
+        case S_IFLNK:
+            break; /* will be processed below */
+        case S_IFBLK:
+        case S_IFCHR:
+        case S_IFDIR:
+        case S_IFIFO:
+        case S_IFSOCK:
+        default:
+            return -3;
+    }
+
+    char target[PATH_MAX]; /* of symlink */
+    errno = 0;
+    ssize_t num_bytes = readlink(full_path, target, sizeof(target));
+    if (num_bytes < 0) {
+        ret = errno;
+        perror("readlink");
+        return ret;
+    }
+    assert((size_t)num_bytes <= sizeof(target));
+    if (num_bytes == sizeof(target)) {
+        fputs("Error: got too long symlink's full path", stderr);
+        return EINVAL;
+    }
+
+    struct symlink* old_tail = head;
+    int depth = 0;
+    for (struct symlink* l = head; l != NULL; l = l->next) {
+        old_tail = l;
+        ++depth;
+        if (strcmp(l->full_path, target) == 0) {
+            fprintf(stderr, "Error: circular dependency detected for symlink: "
+                    "%s", target);
+            return -2;
+        }
+        static const int max_depth = 256;
+        assert(depth <= max_depth);
+        if (depth == max_depth) {
+            fprintf(stderr, "Error: max symlink depth = %d reached", max_depth);
+            return -2;
+        }
+    }
+
+    struct symlink new_tail = {
+        .full_path = target,
+        .next = NULL,
+    };
+    old_tail->next = &new_tail;
+    return is_executable_file(target, head);
+}
+
+/**
+ * @brief find file in $PATH similar to which(1)
+ * @param file_name [IN] - file name to search for in $PATH
+ * @param full_path [OUT] - a pointer to a preallocated buffer of size PATH_MAX
+ * @return 0 on success. In this case full_path is properly initialized (is
+ *           (either executable regular file or a symlink which leads to
+ *           executable regular file).
+ * @return errno value (>0) on system error
+ * @return -1 if file doesn't exist
+ * @return -1 if file is a broken symlink
+ * @return -1 if file is not executable
+ * @return -1 if file is special (neither regular file nor a symlink)
+ * @return -1 if file is a symlink which leads to special file
+ * @return -2 if file is a symlink with circular dependency
+ */
+static int which(const char* file_name, char* full_path)
+{
+    assert(full_path != NULL);
+    const char* path = getenv("PATH");
+    if (path == NULL) {
+        fputs("Error: can't get PATH environment variable", stderr);
+        return EINVAL;
+    }
+
+    int separator = ':';
+    const char* start = path;
+    const char* end;
+    size_t file_name_size = strlen(file_name) + 1;
+    size_t max_num_chars = PATH_MAX - file_name_size - 1 /* for slash */;
+
+    while ((*start) != 0) {
+        if ((*start) == separator) {
+            ++start;
+            continue;
+        }
+        end = strchr(start, separator);
+        if (end == NULL) {
+            end = start + strlen(start);
+            assert((*end) == 0);
+        }
+
+        /* initialize full_path for current entry in $PATH: */
+        size_t num_chars = (size_t)(end - start);
+        if (num_chars > max_num_chars) {
+            fputs("Error: malformed $PATH environment variable or input file"
+                  " name (too long full path detected)\n", stderr);
+            return EINVAL;
+        }
+        if (num_chars == 0) {
+            assert((*end) == 0);
+            break;
+        }
+        memcpy(full_path, start, num_chars);
+        full_path[num_chars] = '/';
+        memcpy(full_path + num_chars + 1, file_name, file_name_size);
+
+        /* analyze full_path: is it a file we are looking for? */
+        struct symlink head = {
+            .full_path = full_path,
+            .next = NULL, /* end of single-linked list */
+        };
+        int ret = is_executable_file(full_path, &head);
+        switch (ret) {
+            case -1: /* full_path doesn't exist or is a broken symlink */
+            case -3: /* full_path is not executable file or a special file
+                      * or a symlink which leads to a special file */
+                break; /* in this case we just proceed to next entry in $PATH */
+            case -2: /* full_path is a symlink with circular dependency */
+            case 0: /* full_path is executable regular file
+                     * or a symlink which leads to executable regular file */
+                return ret;
+            default: /* we've got system error and ret is errno (>0) */
+                assert(ret > 0);
+                return ret;
+        }
+        /* full_path is not a file we are looking for.
+         * Proceed to next entry in $PATH: */
+        start = end;
+    }
+    return -1;
+}
+
 static void report_call(char const *const argv[]) {
     if (!initialized)
         return;
@@ -460,7 +649,18 @@ static void report_call(char const *const argv[]) {
     if (-1 == fd)
         ERROR_AND_EXIT("mkstemp");
     // Write report file
+
+    char full_path[PATH_MAX];
+    const char* prev = argv[0];
+    int ret = which(argv[0], full_path);
+    if (ret == 0)
+        ((char const **)argv)[0] = full_path;
+
     const int finished = write_report(fd, argv);
+
+    if (ret == 0)
+        ((char const **)argv)[0] = prev;
+
     // Close report file
     if (close(fd))
         ERROR_AND_EXIT("close");
diff --git a/bear/main.py.in b/bear/main.py.in
index e36efa1..90fad34 100644
--- a/bear/main.py.in
+++ b/bear/main.py.in
@@ -340,6 +340,15 @@ def capture(args, tools):
         # read the intercepted exec calls
         calls = (parse_exec_trace(file) for file in exec_trace_files(tmp_dir))
         safe_calls = (x for x in calls if x is not None)
+
+        # Add current command (it is not catched by LD_PRELOAD)
+        # This adds support for invocations like: bear gcc file.c
+        import distutils.spawn
+        exe = distutils.spawn.find_executable(args.build[0])
+        cur_cmd = [exe] + args.build[1:] if exe else args.build
+        cmd = Execution(cwd = os.getcwd(), cmd = cur_cmd)
+        safe_calls = list(safe_calls) + [cmd]
+
         current = compilations(safe_calls, tools)
         # filter out not desired entries
         include_filter = include(args.include, args.exclude)
@@ -874,4 +883,5 @@ def temporary_directory(**kwargs):
 
 
 if __name__ == "__main__":
+    # logging.basicConfig(level=logging.DEBUG)
     sys.exit(intercept_build())
